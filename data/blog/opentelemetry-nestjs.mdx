---
title: OpenTelemetry NestJS Implementation Guide: Complete Setup for Production [2025]
slug: opentelemetry-nestjs  
date: 2025-07-24
tags: [OpenTelemetry, NestJS, Distributed Tracing, Observability, APM, Node.js, Monitoring]
authors: [ankit_anand, vishal]
description: Complete guide to implementing OpenTelemetry in NestJS applications with automatic instrumentation, distributed tracing, and production-ready configuration. Includes troubleshooting tips and performance optimization.
keywords: [opentelemetry nestjs, nestjs tracing, nestjs monitoring, distributed tracing, opentelemetry node.js, nestjs observability, opentelemetry instrumentation, signoz nestjs]
---

NestJS applications require comprehensive monitoring to ensure optimal performance and rapid issue resolution. OpenTelemetry provides the industry standard for instrumenting these applications with vendor-agnostic observability through distributed tracing, metrics, and logs.

![Cover Image](/img/blog/2023/01/opentelemetry_nestjs_cover.webp)

Many developers struggle with proper OpenTelemetry implementation in NestJS, facing challenges from initialization order issues to performance concerns and missing traces. This guide addresses these pain points and provides practical, tested solutions for building observable NestJS applications.

Whether you're building microservices or monolithic applications, you'll learn how to configure automatic instrumentation, avoid memory leaks, maintain trace context across async operations, and deploy to production with confidence.

## Why OpenTelemetry for NestJS Applications

NestJS applications, especially those built with microservices architecture, benefit significantly from distributed tracing. Traditional logging approaches fall short when tracking requests across multiple services, databases, and external APIs. OpenTelemetry bridges this gap by providing complete request flow visibility.

The framework's modular architecture aligns perfectly with OpenTelemetry's auto-instrumentation model, which automatically captures HTTP requests, database queries, and inter-service communications without code modifications. This zero-code approach reduces implementation time while providing comprehensive observability coverage.

For production applications, OpenTelemetry offers standardized semantic conventions that ensure consistent data collection across different teams and services. This standardization becomes crucial when debugging complex distributed systems where a single user request might traverse multiple microservices.

## Prerequisites and Setup

Before implementing OpenTelemetry in your NestJS application, ensure you meet these requirements:

- Node.js 18.19.0+ or Node.js 20.6.0+
- TypeScript 5.0.4+
- NestJS 8.0+
- An observability backend (we'll use SigNoz for this guide)

## Quick Implementation Overview

Here's the complete workflow to get OpenTelemetry working with your NestJS application:

1. **Install Required Packages** - Core OpenTelemetry libraries and auto-instrumentations
2. **Create Tracer Configuration** - SDK setup with exporters and instrumentations
3. **Initialize Before Bootstrap** - Critical initialization order for proper tracing
4. **Configure Environment Variables** - Endpoint and authentication setup
5. **Test and Validate** - Verify traces are collected correctly

## Installing Dependencies

Install the essential OpenTelemetry packages for NestJS instrumentation:

```bash
npm install --save @opentelemetry/api@latest
npm install --save @opentelemetry/sdk-node@^2.0.0  
npm install --save @opentelemetry/auto-instrumentations-node@^0.62.0
npm install --save @opentelemetry/exporter-trace-otlp-http@latest
npm install --save @opentelemetry/semantic-conventions@latest
```

The `@opentelemetry/auto-instrumentations-node` package provides automatic instrumentation for popular Node.js libraries including Express, Fastify, HTTP/HTTPS, and database drivers commonly used with NestJS.

## Creating the Tracer Configuration

Create a `tracer.ts` file in your project root that properly initializes the NodeSDK with exporters and instrumentation:

```typescript
import { NodeSDK } from '@opentelemetry/sdk-node';
import { getNodeAutoInstrumentations } from '@opentelemetry/auto-instrumentations-node';
import { OTLPTraceExporter } from '@opentelemetry/exporter-trace-otlp-http';
import { Resource } from '@opentelemetry/resources';
import { SemanticResourceAttributes } from '@opentelemetry/semantic-conventions';

// Configure trace exporter
const traceExporter = new OTLPTraceExporter({
  url: process.env.OTEL_EXPORTER_OTLP_TRACES_ENDPOINT || 'http://localhost:4318/v1/traces',
});

// Create SDK instance with comprehensive configuration
const sdk = new NodeSDK({
  resource: new Resource({
    [SemanticResourceAttributes.SERVICE_NAME]: process.env.OTEL_SERVICE_NAME || 'nestjs-app',
    [SemanticResourceAttributes.SERVICE_VERSION]: process.env.OTEL_SERVICE_VERSION || '1.0.0',
    [SemanticResourceAttributes.DEPLOYMENT_ENVIRONMENT]: process.env.NODE_ENV || 'development',
  }),
  traceExporter,
  instrumentations: [
    getNodeAutoInstrumentations({
      // Disable instrumentations that might cause issues
      '@opentelemetry/instrumentation-fs': { enabled: false },
      // Configure HTTP instrumentation for better trace context
      '@opentelemetry/instrumentation-http': {
        enabled: true,
        ignoreIncomingRequestHook: (req) => {
          // Ignore health check endpoints
          return req.url?.includes('/health') || req.url?.includes('/metrics');
        },
      },
    }),
  ],
});

export default sdk;
```

## Critical Initialization Order

The most common issue with OpenTelemetry in NestJS is incorrect initialization order. The tracer must be initialized before any application code that should be instrumented:

```typescript
// THIS MUST BE THE FIRST IMPORT
import tracer from './tracer';

// Start tracer immediately
await tracer.start();

// Now import NestJS and other application modules
import { NestFactory } from '@nestjs/core';
import { AppModule } from './app.module';
import { Logger } from '@nestjs/common';

async function bootstrap() {
  const logger = new Logger('Bootstrap');
  
  try {
    const app = await NestFactory.create(AppModule);
    
    app.setGlobalPrefix('api');
    app.enableCors();
    
    const port = process.env.PORT || 3000;
    await app.listen(port);
    
    logger.log(`Application running on: http://localhost:${port}/api`);
  } catch (error) {
    logger.error('Error starting application:', error);
    process.exit(1);
  }
}

bootstrap();
```

## Environment Configuration

Configure these environment variables for proper OpenTelemetry operation:

```bash
# Service identification
OTEL_SERVICE_NAME=your-nestjs-app
OTEL_SERVICE_VERSION=1.0.0

# Exporter configuration
OTEL_EXPORTER_OTLP_TRACES_ENDPOINT=http://localhost:4318/v1/traces
OTEL_EXPORTER_OTLP_HEADERS=Authorization=Bearer <your-token>

# Environment
NODE_ENV=development

# Optional: Additional resource attributes
OTEL_RESOURCE_ATTRIBUTES=service.name=your-nestjs-app,service.version=1.0.0
```

## Custom Instrumentation with Decorators

While automatic instrumentation covers HTTP requests and database operations, you'll often need custom spans for business-critical operations. Create a tracing decorator for clean implementation:

```typescript
import { trace, context, SpanStatusCode } from '@opentelemetry/api';

export function Traced(spanName?: string) {
  return function (target: any, propertyKey: string, descriptor: PropertyDescriptor) {
    const originalMethod = descriptor.value;
    const tracer = trace.getTracer('nestjs-app', '1.0.0');
    
    descriptor.value = async function (...args: any[]) {
      const finalSpanName = spanName || `${target.constructor.name}.${propertyKey}`;
      
      return await tracer.startActiveSpan(finalSpanName, async (span) => {
        try {
          span.setAttributes({
            'method.class': target.constructor.name,
            'method.name': propertyKey,
          });
          
          const result = await originalMethod.apply(this, args);
          span.setStatus({ code: SpanStatusCode.OK });
          return result;
          
        } catch (error) {
          span.recordException(error);
          span.setStatus({ 
            code: SpanStatusCode.ERROR, 
            message: error.message 
          });
          throw error;
        } finally {
          span.end();
        }
      });
    };
    
    return descriptor;
  };
}

// Usage in your services
@Injectable()
export class UserService {
  @Traced('user_creation')
  async createUser(userData: CreateUserDto): Promise<User> {
    // Your business logic
  }

  @Traced() // Uses default name: UserService.findById
  async findById(id: string): Promise<User> {
    // Your business logic
  }
}
```

## Database Query Instrumentation

Ensure proper database tracing for TypeORM, Prisma, or Mongoose operations:

```typescript
import { Injectable } from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import { Repository } from 'typeorm';
import { trace, SpanStatusCode } from '@opentelemetry/api';
import { User } from './entities/user.entity';

@Injectable()
export class UserRepository {
  private readonly tracer = trace.getTracer('database', '1.0.0');

  constructor(
    @InjectRepository(User)
    private readonly userRepository: Repository<User>
  ) {}

  async findUsersWithFilters(filters: UserFilters): Promise<User[]> {
    return await this.tracer.startActiveSpan('complex_user_query', async (span) => {
      try {
        span.setAttributes({
          'db.operation': 'select',
          'db.table': 'users',
          'query.filters': JSON.stringify(filters)
        });

        const queryBuilder = this.userRepository
          .createQueryBuilder('user')
          .leftJoinAndSelect('user.profile', 'profile');

        if (filters.email) {
          queryBuilder.where('user.email LIKE :email', { 
            email: `%${filters.email}%` 
          });
        }

        const users = await queryBuilder.getMany();
        
        span.setAttributes({
          'query.result_count': users.length,
        });
        
        span.setStatus({ code: SpanStatusCode.OK });
        return users;

      } catch (error) {
        span.recordException(error);
        span.setStatus({ 
          code: SpanStatusCode.ERROR, 
          message: error.message 
        });
        throw error;
      } finally {
        span.end();
      }
    });
  }
}
```

## Distributed Tracing Across Microservices

For microservices communication, ensure proper context propagation:

```typescript
import { Injectable, Logger } from '@nestjs/common';
import { HttpService } from '@nestjs/axios';
import { trace, context, propagation } from '@opentelemetry/api';
import { firstValueFrom } from 'rxjs';

@Injectable()
export class OrderService {
  private readonly logger = new Logger(OrderService.name);
  private readonly tracer = trace.getTracer('order-service', '1.0.0');

  constructor(private readonly httpService: HttpService) {}

  async createOrder(orderData: CreateOrderDto): Promise<Order> {
    return await this.tracer.startActiveSpan('create_order', async (span) => {
      try {
        span.setAttributes({
          'order.user_id': orderData.userId,
          'order.items_count': orderData.items.length,
          'order.total_amount': orderData.totalAmount,
        });

        // Process payment with context propagation
        const paymentResult = await this.processPayment(orderData);
        
        // Create order record
        const order = await this.saveOrder(orderData, paymentResult);

        span.setStatus({ code: SpanStatusCode.OK });
        return order;
        
      } catch (error) {
        span.recordException(error);
        span.setStatus({ 
          code: SpanStatusCode.ERROR,
          message: error.message 
        });
        throw error;
      } finally {
        span.end();
      }
    });
  }

  private async processPayment(orderData: CreateOrderDto): Promise<PaymentResult> {
    return await this.tracer.startActiveSpan('process_payment', async (span) => {
      try {
        // Create headers with trace context for downstream service
        const headers = {};
        propagation.inject(context.active(), headers);

        const paymentRequest = {
          userId: orderData.userId,
          amount: orderData.totalAmount,
          paymentMethod: orderData.paymentMethod,
        };

        const response = await firstValueFrom(
          this.httpService.post('http://payment-service:3003/api/process', 
            paymentRequest, 
            { headers }
          )
        );

        span.setAttributes({
          'payment.transaction_id': response.data.transactionId,
          'payment.amount': orderData.totalAmount,
          'payment.status': response.data.status,
        });

        span.setStatus({ code: SpanStatusCode.OK });
        return response.data;
        
      } catch (error) {
        span.recordException(error);
        span.setStatus({ 
          code: SpanStatusCode.ERROR,
          message: error.message 
        });
        throw error;
      } finally {
        span.end();
      }
    });
  }
}
```

## Performance Optimization for Production

Configure sampling and batch processing for production environments:

```typescript
import { NodeSDK } from '@opentelemetry/sdk-node';
import { TraceIdRatioBasedSampler, ParentBasedSampler, BatchSpanProcessor } from '@opentelemetry/sdk-trace-base';

const isProduction = process.env.NODE_ENV === 'production';

// Production-optimized configuration
const sdk = new NodeSDK({
  // Sample 10% of traces in production, 100% in development
  sampler: new ParentBasedSampler({
    root: new TraceIdRatioBasedSampler(isProduction ? 0.1 : 1.0),
  }),
  
  // Batch export for better performance
  spanProcessor: new BatchSpanProcessor(traceExporter, {
    maxExportBatchSize: isProduction ? 200 : 50,
    exportTimeoutMillis: isProduction ? 5000 : 2000,
    scheduledDelayMillis: isProduction ? 2000 : 1000,
  }),
  
  resource: new Resource({
    [SemanticResourceAttributes.SERVICE_NAME]: process.env.OTEL_SERVICE_NAME,
    [SemanticResourceAttributes.SERVICE_VERSION]: process.env.OTEL_SERVICE_VERSION,
    [SemanticResourceAttributes.DEPLOYMENT_ENVIRONMENT]: process.env.NODE_ENV,
  }),
  
  instrumentations: [
    getNodeAutoInstrumentations({
      // Disable high-volume instrumentation in production
      '@opentelemetry/instrumentation-fs': { enabled: false },
      '@opentelemetry/instrumentation-dns': { enabled: false },
      
      '@opentelemetry/instrumentation-http': {
        enabled: true,
        ignoreIncomingRequestHook: (req) => {
          const ignorePaths = ['/health', '/metrics', '/favicon.ico'];
          return ignorePaths.some(path => req.url?.includes(path));
        },
      },
    }),
  ],
});
```

## Resource Management and Cleanup

Implement proper resource cleanup to prevent memory leaks:

```typescript
import { Injectable, OnModuleDestroy, Logger } from '@nestjs/common';
import { NodeSDK } from '@opentelemetry/sdk-node';

@Injectable()
export class TelemetryService implements OnModuleDestroy {
  private readonly logger = new Logger(TelemetryService.name);
  private sdk: NodeSDK;

  async initializeTelemetry(): Promise<void> {
    try {
      this.sdk = new NodeSDK({
        // Your SDK configuration
      });

      await this.sdk.start();
      this.logger.log('OpenTelemetry SDK initialized successfully');
      
      // Handle process shutdown gracefully
      process.on('SIGTERM', () => this.shutdown());
      process.on('SIGINT', () => this.shutdown());
      
    } catch (error) {
      this.logger.error('Failed to initialize OpenTelemetry SDK:', error);
      throw error;
    }
  }

  async onModuleDestroy(): Promise<void> {
    await this.shutdown();
  }

  private async shutdown(): Promise<void> {
    try {
      if (this.sdk) {
        this.logger.log('Shutting down OpenTelemetry SDK...');
        await this.sdk.shutdown();
        this.logger.log('OpenTelemetry SDK shutdown complete');
      }
    } catch (error) {
      this.logger.error('Error during OpenTelemetry SDK shutdown:', error);
    }
  }
}
```

## Common Troubleshooting Issues

### Missing Traces

**Initialization Order Problems:**
```typescript
// ❌ WRONG - NestJS imports before tracer
import { NestFactory } from '@nestjs/core';
import tracer from './tracer';

// ✅ CORRECT - Tracer first
import tracer from './tracer';
await tracer.start();
import { NestFactory } from '@nestjs/core';
```

**Debug with Console Exporter:**
```typescript
import { ConsoleSpanExporter } from '@opentelemetry/sdk-trace-base';

// Temporarily use console exporter to verify traces are generated
const debugExporter = new ConsoleSpanExporter();

const sdk = new NodeSDK({
  traceExporter: process.env.NODE_ENV === 'development' 
    ? debugExporter 
    : traceExporter,
});
```

### Memory and Performance Issues

**Configure EventEmitter Limits:**
```typescript
import { EventEmitter } from 'events';

// Increase max listeners limit for production
EventEmitter.defaultMaxListeners = 20;

// Use sampling to reduce memory pressure
const sdk = new NodeSDK({
  sampler: new TraceIdRatioBasedSampler(0.1), // 10% sampling
});
```

### Context Propagation Failures

**Verify Propagator Configuration:**
```typescript
import { CompositePropagator, TraceContextPropagator, BaggagePropagator } from '@opentelemetry/core';
import { B3Propagator } from '@opentelemetry/propagator-b3';

const sdk = new NodeSDK({
  textMapPropagator: new CompositePropagator({
    propagators: [
      new TraceContextPropagator(),
      new BaggagePropagator(),
      new B3Propagator(),
    ],
  }),
});
```

## Get Started with SigNoz

SigNoz provides comprehensive monitoring and observability features specifically designed for NestJS applications. The platform automatically captures distributed traces, metrics, and logs from your instrumented NestJS application, supporting REST APIs, GraphQL endpoints, and microservices architectures.

Key features for NestJS applications include:

- **Automatic RED Metrics**: Request Rate, Error Rate, and Duration visualization without manual configuration
- **Distributed Tracing**: End-to-end trace visualization across microservices with flamegraphs and Gantt charts
- **Database Query Analysis**: Deep insights into TypeORM, Prisma, and database performance
- **Custom Business Metrics**: Track specific NestJS service operations and business KPIs
- **Real-time Alerting**: Set up alerts for latency, error rates, and custom metrics

You can choose between various deployment options in SigNoz. The easiest way to get started with SigNoz is [SigNoz cloud](https://signoz.io/teams/). We offer a 30-day free trial account with access to all features.

Those who have data privacy concerns and can't send their data outside their infrastructure can sign up for either [enterprise self-hosted or BYOC offering](https://signoz.io/contact-us/).

Those who have the expertise to manage SigNoz themselves or just want to start with a free self-hosted option can use our [community edition](https://signoz.io/docs/install/self-host/).

Hope we answered all your questions regarding OpenTelemetry NestJS implementation. If you have more questions, feel free to use the SigNoz AI chatbot, or join our [slack community](https://signoz.io/slack/).

## Conclusion

OpenTelemetry provides robust, production-ready observability for NestJS applications when properly implemented. Success depends on correct initialization order, appropriate sampling configuration, and understanding common implementation pitfalls.

The automatic instrumentation capabilities cover most use cases, capturing HTTP requests, database operations, and external API calls without code modifications. For business-critical operations, custom spans and decorators provide granular visibility into application behavior.

Performance overhead remains manageable at 5-10% when properly configured with sampling and batch processing. The benefits of comprehensive observability—faster debugging, improved system understanding, and proactive issue detection—far outweigh this minimal cost.

For microservices architectures, proper context propagation ensures traces remain connected across service boundaries, providing end-to-end visibility into complex distributed operations.

With OpenTelemetry's vendor-neutral approach and SigNoz's comprehensive NestJS support, you can implement production-grade observability that scales with your application growth.

## Frequently Asked Questions

**What's the minimum Node.js version required for OpenTelemetry SDK 2.0?**
OpenTelemetry SDK 2.0+ requires Node.js 18.19.0+ or Node.js 20.6.0+, along with TypeScript 5.0.4+.

**How do I debug missing traces in my NestJS application?** 
Use the ConsoleSpanExporter in development to verify traces are generated. Check initialization order (tracer must start before NestJS imports), validate exporter configuration, and ensure environment variables are set.

**What's the performance overhead of OpenTelemetry instrumentation?**
With proper configuration (sampling, batch processing), expect 5-10% performance overhead. This can be reduced by disabling unnecessary instrumentations and optimizing sampling rates.

**Can I use OpenTelemetry with GraphQL in NestJS?**
Yes, OpenTelemetry's HTTP instrumentation automatically captures GraphQL requests. For detailed GraphQL-specific tracing, create custom spans around resolver methods.

**Should I use automatic or manual instrumentation?**
Start with automatic instrumentation for framework operations (HTTP, database, external calls), then add manual instrumentation for business-critical operations requiring custom context.

**How do I correlate logs with traces?**
Extract trace and span IDs from the current active span and include them in log statements. This enables correlation between log entries and traces in your observability platform.
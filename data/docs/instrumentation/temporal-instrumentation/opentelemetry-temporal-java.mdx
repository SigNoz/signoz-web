---
date: 2025-03-03
title: Temporal Metrics using OpenTelemetry
id: opentelemetry-temporal-metrics
description: Learn how to instrument Temporal applications to send metrics to SigNoz using OpenTelemetry
---

### Step 1: Add OpenTelemetry Dependencies

Add to your `pom.xml`:

```xml
<properties>
    <opentelemetry.version>1.34.1</opentelemetry.version>
    <temporal.version>1.24.1</temporal.version>
</properties>

<dependencies>
    <!-- Temporal -->
    <dependency>
        <groupId>io.temporal</groupId>
        <artifactId>temporal-sdk</artifactId>
        <version>${temporal.version}</version>
    </dependency>
    <dependency>
        <groupId>io.temporal</groupId>
        <artifactId>temporal-opentracing</artifactId>
        <version>${temporal.version}</version>
    </dependency>

    <!-- OpenTelemetry -->
    <dependency>
        <groupId>io.opentelemetry</groupId>
        <artifactId>opentelemetry-api</artifactId>
        <version>${opentelemetry.version}</version>
    </dependency>
    <dependency>
        <groupId>io.opentelemetry</groupId>
        <artifactId>opentelemetry-sdk</artifactId>
        <version>${opentelemetry.version}</version>
    </dependency>
    <dependency>
        <groupId>io.opentelemetry</groupId>
        <artifactId>opentelemetry-exporter-otlp</artifactId>
        <version>${opentelemetry.version}</version>
    </dependency>
    <dependency>
        <groupId>io.opentelemetry</groupId>
        <artifactId>opentelemetry-extension-trace-propagators</artifactId>
        <version>${opentelemetry.version}</version>
    </dependency>
</dependencies>
```

### Step 2: Configure OpenTelemetry

Create `SignozTelemetryUtils.java` to configure OpenTelemetry with SigNoz OTLP exporter, trace propagation, and Temporal interceptors:

```java:src/main/java/helloworld/config/SignozTelemetryUtils.java
package helloworld.config;

import com.uber.m3.tally.Scope;
import io.opentelemetry.api.OpenTelemetry;
import io.opentelemetry.api.metrics.Meter;
import io.opentelemetry.api.trace.Tracer;
import io.opentelemetry.context.propagation.ContextPropagators;
import io.opentelemetry.api.trace.propagation.W3CTraceContextPropagator;
import io.opentelemetry.sdk.OpenTelemetrySdk;
import io.opentelemetry.sdk.resources.Resource;
import io.temporal.common.interceptors.WorkerInterceptor;
import java.util.logging.Level;
import java.util.logging.Logger;

public class SignozTelemetryUtils {
    private static final Logger logger = Logger.getLogger(SignozTelemetryUtils.class.getName());
    private static volatile boolean initialized = false;
    private static Meter meter;
    private static Tracer tracer;
    
    public static synchronized void initializeTelemetry() {
        if (initialized) {
            return;
        }
        
        logger.info("Initializing OpenTelemetry...");
        
        try {
            // Create resource with service info
            Resource resource = OpenTelemetryConfig.createResource();
            
            // Build SDK with metrics and tracing support
            OpenTelemetrySdk sdk = OpenTelemetrySdk.builder()
                .setTracerProvider(TracingExporter.createTracerProvider())
                .setMeterProvider(MetricsExporter.createMeterProvider())
                .setPropagators(ContextPropagators.create(W3CTraceContextPropagator.getInstance()))
                .build();
            
            OpenTelemetryConfig.setOpenTelemetry(sdk);
            
            // Initialize meters and tracers
            meter = sdk.getMeter("io.temporal");
            tracer = sdk.getTracer("io.temporal");
            
            // Initialize workflow metrics for the dashboard
            WorkflowMetricsUtil.initializeMetrics();
            
            // Add shutdown hook for clean telemetry shutdown
            Runtime.getRuntime().addShutdownHook(new Thread(() -> {
                logger.info("Shutting down OpenTelemetry...");
                
                // First, clean up WorkflowMetricsUtil resources
                WorkflowMetricsUtil.cleanup();
                
                // Force metrics export before shutdown
                try {
                    // Allow time for any pending metrics to be exported
                    Thread.sleep(500);
                } catch (InterruptedException e) {
                    logger.log(Level.WARNING, "Interrupted during shutdown delay", e);
                }
                
                // Shutdown exporters
                TracingExporter.shutdown();
                MetricsExporter.shutdown();
                
                // Reset local references
                meter = null;
                tracer = null;
                initialized = false;
            }));
            
            initialized = true;
            logger.info("OpenTelemetry initialization complete");
        } catch (Exception e) {
            logger.log(Level.SEVERE, "Error initializing OpenTelemetry", e);
        }
    }
    
    public static Meter getMeter() {
        if (!initialized) {
            logger.warning("OpenTelemetry not initialized. Call initializeTelemetry() first.");
        }
        return meter;
    }
    
    public static Tracer getTracer() {
        if (!initialized) {
            logger.warning("OpenTelemetry not initialized. Call initializeTelemetry() first.");
        }
        return tracer;
    }
    
    public static Scope getMetricsScope() {
        return MetricsExporter.getMetricsScope();
    }

    public static WorkerInterceptor getWorkerInterceptor() {
        return TracingExporter.getWorkerInterceptor();
    }
    
    private SignozTelemetryUtils() {
        // Prevent instantiation - use static methods
    }
}
```

### Step 3: Configure OpenTelemetry Settings

Create `OpenTelemetryConfig.java` to manage OpenTelemetry configuration including service attributes, resource settings, and endpoint configuration. This class will be used by the telemetry utilities to initialize the OpenTelemetry SDK.

```java:src/main/java/helloworld/config/OpenTelemetryConfig.java
package helloworld.config;

import io.opentelemetry.api.OpenTelemetry;
import io.opentelemetry.api.common.Attributes;
import io.opentelemetry.api.common.AttributeKey;
import io.opentelemetry.api.trace.propagation.W3CTraceContextPropagator;
import io.opentelemetry.context.propagation.ContextPropagators;
import io.opentelemetry.sdk.OpenTelemetrySdk;
import io.opentelemetry.sdk.resources.Resource;
import io.temporal.client.WorkflowClient;
import io.temporal.serviceclient.WorkflowServiceStubs;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.HashMap;
import java.util.Map;

public final class OpenTelemetryConfig {
    private static final Logger logger = Logger.getLogger(OpenTelemetryConfig.class.getName());

    // Default values used when environment variables are not set
    public static final String DEFAULT_SIGNOZ_ENDPOINT = "http://localhost:4317";

    //OpenTelemetry resource attribute keys for custom attribute creation
    public static final AttributeKey<String> SERVICE_NAME = AttributeKey.stringKey("service.name");
    public static final AttributeKey<String> ACCESS_TOKEN = AttributeKey.stringKey("signoz-access-token");
    public static final AttributeKey<String> SERVICE_NAMESPACE = AttributeKey.stringKey("service.namespace");
    public static final AttributeKey<String> DEPLOYMENT_ENVIRONMENT = AttributeKey.stringKey("deployment.environment");

    // Environment variables for configuration override
    private static final String ENV_OTEL_ENDPOINT = "OTEL_EXPORTER_OTLP_ENDPOINT";  // Collector endpoint
    private static final String ENV_ENVIRONMENT = "OTEL_ENVIRONMENT";               // Deployment environment
    private static final String ENV_RESOURCE_ATTRIBUTES = "OTEL_RESOURCE_ATTRIBUTES"; // Resource attributes
    private static final String ENV_SIGNOZ_ACCESS_TOKEN = "OTEL_EXPORTER_OTLP_HEADERS"; // SigNoz access token

    // Global SDK instance - initialized by SignozTelemetryUtils
    private static volatile OpenTelemetry openTelemetry;
    private static WorkflowServiceStubs service;
    private static WorkflowClient client;
    private static volatile Resource resource;

    public static OpenTelemetry getOpenTelemetry() {
        if (openTelemetry == null) {
            throw new IllegalStateException("OpenTelemetry not initialized. Call initialize() first.");
        }
        return openTelemetry;
    }

    public static Resource createResource() {
        if (resource != null) {
            return resource;
        }

        synchronized (OpenTelemetryConfig.class) {
            if (resource != null) {
                return resource;
            }

            String environment = System.getenv().getOrDefault(ENV_ENVIRONMENT, "development");
            
            // Parse OTEL_RESOURCE_ATTRIBUTES
            String resourceAttrs = System.getenv(ENV_RESOURCE_ATTRIBUTES);
            Map<AttributeKey<String>, String> attributes = new HashMap<>();
            
            if (resourceAttrs != null) {
                // Parse comma-separated key-value pairs
                for (String pair : resourceAttrs.split(",")) {
                    String[] keyValue = pair.trim().split("=", 2);
                    if (keyValue.length == 2) {
                        String key = keyValue[0].trim();
                        String value = keyValue[1].trim();
                        if ("service.name".equals(key)) {
                            attributes.put(SERVICE_NAME, value);
                        }
                    }
                }
            }

            // Verify service.name is set
            if (!attributes.containsKey(SERVICE_NAME)) {
                throw new IllegalStateException(
                    "service.name must be configured via OTEL_RESOURCE_ATTRIBUTES environment variable. " +
                    "Example: OTEL_RESOURCE_ATTRIBUTES=service.name=your-service-name"
                );
            }

            // Create resource with attributes
            resource = Resource.create(
                Attributes.of(
                    SERVICE_NAME, attributes.get(SERVICE_NAME),
                    SERVICE_NAMESPACE, "default",
                    DEPLOYMENT_ENVIRONMENT, environment
                )
            );
            
            logger.info("Creating resource with service.name: " + attributes.get(SERVICE_NAME));
            logger.info("Environment: " + environment);
            logger.info("Resource attributes: " + resourceAttrs);
            
            return Resource.getDefault().merge(resource);
        }
    }

    public static String getEndpoint() {
        String endpoint = System.getenv().getOrDefault(ENV_OTEL_ENDPOINT, DEFAULT_SIGNOZ_ENDPOINT);
        
        // Ensure the endpoint starts with a protocol
        if (!endpoint.startsWith("http://") && !endpoint.startsWith("https://")) {
            endpoint = "http://" + endpoint;
        }
        
        return endpoint;
    }

    public static String getAccessToken() {
        return System.getenv().get(ENV_SIGNOZ_ACCESS_TOKEN);
    }

    public static String getResourceAttributes() {
        return System.getenv().get(ENV_RESOURCE_ATTRIBUTES);
    }

    public static String getServiceName() {
        String resourceAttrs[] = System.getenv(ENV_RESOURCE_ATTRIBUTES).split(",");
        for (String pair : resourceAttrs) {
            String[] keyValue = pair.trim().split("=", 2);
            if ("service.name".equals(keyValue[0].trim())) {
                return keyValue[1].trim();
            }
        }
        return "temporal-hello-world";
    }

    protected static synchronized void setOpenTelemetry(OpenTelemetrySdk sdk) {
        if (openTelemetry != null) {
            throw new IllegalStateException("OpenTelemetry already initialized");
        }
        openTelemetry = sdk;
    }

    private OpenTelemetryConfig() {
        // Prevent instantiation - use static methods
    }
}
```

### Step 4: Set Up Metrics Export

Create `MetricsExporter.java` to configure metrics export to SigNoz with OTLP/gRPC, batch processing, and Temporal metrics:

```java:src/main/java/helloworld/config/MetricsExporter.java
package helloworld.config;

import io.opentelemetry.exporter.otlp.metrics.OtlpGrpcMetricExporter;
import io.opentelemetry.sdk.metrics.SdkMeterProvider;
import io.opentelemetry.sdk.metrics.export.PeriodicMetricReader;
import io.opentelemetry.sdk.metrics.InstrumentSelector;
import io.opentelemetry.sdk.metrics.View;
import com.uber.m3.tally.NoopScope;
import com.uber.m3.tally.Scope;
import java.util.logging.Logger;
import java.util.concurrent.TimeUnit;

public class MetricsExporter {
    private static final Logger logger = Logger.getLogger(MetricsExporter.class.getName());
    private static Scope metricsScope;
    private static PeriodicMetricReader metricReader;

    public static synchronized Scope getMetricsScope() {
        if (metricsScope == null) {
            metricsScope = new NoopScope();
        }
        return metricsScope;
    }

    public static SdkMeterProvider createMeterProvider() {
        String endpoint = OpenTelemetryConfig.getEndpoint();
        String accessToken = OpenTelemetryConfig.getAccessToken();
        
        // Parse the header key and value
        String headerKey = null;
        String headerValue = accessToken;
        if (accessToken != null && accessToken.contains("=")) {
            String[] parts = accessToken.split("=", 2);
            headerKey = parts[0];
            headerValue = parts[1];
        }

        // Create OTLP metric exporter
        OtlpGrpcMetricExporter metricExporter;
        if (headerKey != null && headerValue != null && !headerValue.isEmpty()) {
            logger.info("Metrics header key: " + headerKey);
            logger.info("Metrics endpoint: " + endpoint);
            metricExporter = OtlpGrpcMetricExporter.builder()
                .setEndpoint(endpoint)
                .addHeader(headerKey, headerValue)
                .setTimeout(java.time.Duration.ofSeconds(60))
                .build();
        } else {
            metricExporter = OtlpGrpcMetricExporter.builder()
                .setEndpoint(endpoint)
                .setTimeout(java.time.Duration.ofSeconds(60))
                .build();
        }

        // Create metric reader with optimized settings
        metricReader = PeriodicMetricReader.builder(metricExporter)
            .setInterval(java.time.Duration.ofSeconds(1))  // More frequent updates for better visibility
            .build();

        // Create views for workflow metrics
        View workflowStartedView = View.builder()
            .setName("workflow_started_count_total")
            .setDescription("Total number of workflow executions started")
            .setAggregation(io.opentelemetry.sdk.metrics.Aggregation.sum())
            .build();

        View workflowCompletedView = View.builder()
            .setName("workflow_completed_count_total")
            .setDescription("Total number of workflow executions completed")
            .setAggregation(io.opentelemetry.sdk.metrics.Aggregation.sum())
            .build();

        // Create and return meter provider with views
        return SdkMeterProvider.builder()
            .setResource(OpenTelemetryConfig.createResource())
            .registerMetricReader(metricReader)
            .registerView(
                InstrumentSelector.builder()
                    .setName("workflow_started_count_total")
                    .build(),
                workflowStartedView)
            .registerView(
                InstrumentSelector.builder()
                    .setName("workflow_completed_count_total")
                    .build(),
                workflowCompletedView)
            .build();
    }

    public static void shutdown() {
        if (metricReader != null) {
            try {
                logger.info("Shutting down metrics reader...");
                
                // First flush any pending metrics
                try {
                    metricReader.forceFlush().join(10, TimeUnit.SECONDS);
                    logger.info("Metrics flush completed");
                } catch (Exception e) {
                    logger.warning("Metrics flush failed: " + e.getMessage());
                }
                
                // Then shutdown the reader
                try {
                    metricReader.shutdown().join(10, TimeUnit.SECONDS);
                    logger.info("Metrics reader shutdown completed successfully");
                } catch (Exception e) {
                    logger.warning("Metrics reader shutdown failed: " + e.getMessage());
                }
            } catch (Exception e) {
                logger.severe("Error during metrics reader shutdown: " + e.getMessage());
            } finally {
                metricReader = null;
                metricsScope = null;
            }
        }
    }

    private MetricsExporter() {
        // Prevent instantiation - use static methods
    }
}
```

### Step 5: Configure Worker with Metrics

Configure your Temporal Worker to initialize and integrate OpenTelemetry metrics collection:

```java:src/main/java/helloworld/workers/HelloWorldWorker.java
public class HelloWorldWorker implements AutoCloseable {
    ...

    public HelloWorldWorker() {
        // Initialize OpenTelemetry SDK for metrics collection
        SignozTelemetryUtils.initializeTelemetry();

        // Configure Temporal client to expose metrics through OpenTelemetry
        WorkflowServiceStubsOptions stubOptions = WorkflowServiceStubsOptions.newBuilder()
            .setMetricsScope(SignozTelemetryUtils.getMetricsScope()) // Get OTEL metrics context
            .build();

        // Enable workflow-level metric tracking via interceptor
        WorkerFactoryOptions factoryOptions = WorkerFactoryOptions.newBuilder()
            .setWorkerInterceptors(SignozTelemetryUtils.getWorkerInterceptor()) // Metrics collection hook
            .build();

        ... //Temporal worker initialization
    }

    public void start() {
        try {
            ... // worker startup
            
            // Register custom metric definitions (counter/gauges/histograms)
            TemporalConfig.registerDashboardMetrics();
            
            ... //shutdown hook setup
        } catch (Exception e) {
            ... // Error handling
        }
    }

    @Override
    public void close() {
        ... // Temporal shutdown logic
        
        try {            
            // Release metric resources before shutdown
            helloworld.config.WorkflowMetricsUtil.cleanup();
            
            // Flush remaining metric data to exporter
            SignozTelemetryUtils.getMetricsScope().close();
            
            // Allow buffer time for final metric exports
            Thread.sleep(1000);
            
            // Shutdown metrics export pipeline
            MetricsExporter.shutdown();

            ... // Remaining cleanup
        } catch (Exception e) {
            ... // Error handling
        }
    }
}
```

### Step 6: Configure Workflow Starter
Update your Temporal Workflow Starter to initialize OpenTelemetry for metrics:

```java:src/main/java/helloworld/main/HelloWorldStarter.java
public class HelloWorldStarter {
    ...

    public HelloWorldStarter() {
        // 1. Initialize OpenTelemetry metrics collection
        SignozTelemetryUtils.initializeTelemetry();

        // 2. Create metrics instruments
        Meter meter = SignozTelemetryUtils.getMeter();
        workflowCompletionCounter = meter
            .counterBuilder("workflow_completed_count_total")
            .setDescription("Tracks total completed workflows")
            .build();
            
        workflowStartCounter = meter
            .counterBuilder("workflow_started_count_total")
            .setDescription("Tracks total initiated workflows")
            .build();

        // 3. Attach metrics collection to Temporal client
        WorkflowServiceStubsOptions stubOptions = WorkflowServiceStubsOptions.newBuilder()
            .setMetricsScope(SignozTelemetryUtils.getMetricsScope()) // Connect OTEL metrics
            .build();

        ... // Rest ofclient setup
    }

    public void runWorkflow(String name) {
        ... //workflow setup
        
        try {
            // 4. Record workflow initiation metric
            workflowStartCounter.add(1L);
            
            ... // Workflow execution logic
            
            // 5. Record successful completion metric
            workflowCompletionCounter.add(1L);
            WorkflowMetricsUtil.recordSuccess(...);
            
        } catch (Exception e) {
            // 6. Record failure metric
            WorkflowMetricsUtil.recordFailure(...);
            ...
        } finally {
            // 7. Ensure metrics export cleanup
            MetricsExporter.shutdown();
            Thread.sleep(1000); // Allow final metric flush
            ...
        }
    }

    ... // Main method
}
```
---
date: 2025-03-03
id: opentelemetry-temporal-traces
title: Temporal Traces using OpenTelemetry
description: Learn how to instrument Temporal applications to send traces to SigNoz using OpenTelemetry
---

import InstrumentationFAQ from '@/components/shared/instrumentation-faq.md'

This document contains instructions on how to set up OpenTelemetry instrumentation in your Temporal applications and view your application traces in SigNoz.

## Requirements

- Temporal server (self-hosted or Cloud)
- Java 11+, Go 1.19+, or Node.js 16+ depending on your application
- Temporal application

## Temporal Server Setup

<Tabs>
<TabItem value="temporal-self-hosted" label="Self-Hosted Temporal" default>

1. Install [Temporal CLI](https://github.com/temporalio/cli/releases)

2. Start the development server:
```bash
temporal server start-dev --ui-port 8080
```

This starts:
- Temporal Server on port 7233
- Web UI on port 8080 (http://localhost:8080)
- Default namespace: "default"

<figure data-zoomable align='center'>
    <img src="/img/docs/instrumentation/temporal-self-hosted-ui.webp" alt="Temporal Web UI Dashboard"/>
    <figcaption><i>Temporal Self-Hosted UI</i></figcaption>
</figure>

<figure data-zoomable align='center'>
    <img src="/img/docs/instrumentation/temporal-self-hosted-traces.webp" alt="Temporal Traces"/>
    <figcaption><i>Temporal Traces</i></figcaption>
</figure>

</TabItem>

<TabItem value="temporal-cloud" label="Temporal Cloud">

1. Install [Temporal CLI](https://github.com/temporalio/cli/releases)

2. **Generate mTLS Certificate**
- Go to Temporal Cloud Console and follow the [generation instructions](https://docs.temporal.io/cloud/certificates) or use your own certificates following [Temporal's requirements](https://docs.temporal.io/cloud/certificates#certificate-requirements)

3. **Create Namespace**
- Create a namespace in Temporal Cloud Console (e.g., default, dev-namespace, prod-namespace)

4. **Verify Connection**
```bash
temporal workflow list \
  --address <namespace>.<account_id>.tmprl.cloud:7233 \
  --namespace <namespace>.<account_id> \
  --tls-cert-path <cert.pem> \
  --tls-key-path <cert.key>
```
This command should return an empty response for a new namespace.

5. **Configure Environment**
```bash
# Temporal Cloud
export TEMPORAL_HOST_URL=<namespace>.<account_id>.tmprl.cloud:7233
export TEMPORAL_NAMESPACE=<namespace>.<account_id>
export TEMPORAL_TLS_CERT=<cert.pem>
export TEMPORAL_TLS_KEY=<cert.key>
```

<figure data-zoomable align='center'>
    <img src="/img/docs/instrumentation/temporal-cloud-ui.webp" alt="Temporal Cloud UI Dashboard"/>
    <figcaption><i>Temporal Cloud UI</i></figcaption>
</figure>

<figure data-zoomable align='center'>
    <img src="/img/docs/instrumentation/temporal-cloud-traces.webp" alt="Temporal Cloud Traces"/>
    <figcaption><i>Temporal Cloud Traces</i></figcaption>
</figure>
</TabItem>
</Tabs>

## Implementation

<Tabs>
<TabItem value="signoz-self-host" label="Self-Hosted SigNoz" default>
<Tabs>
<TabItem value="java" label="Java" default>

### Step 1: Add OpenTelemetry Dependencies

Add to your `pom.xml`:

```xml
<properties>
    <opentelemetry.version>1.34.1</opentelemetry.version>
    <temporal.version>1.24.1</temporal.version>
</properties>

<dependencies>
    <!-- Temporal -->
    <dependency>
        <groupId>io.temporal</groupId>
        <artifactId>temporal-sdk</artifactId>
        <version>${temporal.version}</version>
    </dependency>
    <dependency>
        <groupId>io.temporal</groupId>
        <artifactId>temporal-opentracing</artifactId>
        <version>${temporal.version}</version>
    </dependency>

    <!-- OpenTelemetry -->
    <dependency>
        <groupId>io.opentelemetry</groupId>
        <artifactId>opentelemetry-api</artifactId>
        <version>${opentelemetry.version}</version>
    </dependency>
    <dependency>
        <groupId>io.opentelemetry</groupId>
        <artifactId>opentelemetry-sdk</artifactId>
        <version>${opentelemetry.version}</version>
    </dependency>
    <dependency>
        <groupId>io.opentelemetry</groupId>
        <artifactId>opentelemetry-exporter-otlp</artifactId>
        <version>${opentelemetry.version}</version>
    </dependency>
    <dependency>
        <groupId>io.opentelemetry</groupId>
        <artifactId>opentelemetry-extension-trace-propagators</artifactId>
        <version>${opentelemetry.version}</version>
    </dependency>
</dependencies>
```

### Step 2: Configure OpenTelemetry

Create `SignozTelemetryUtils.java` to configure OpenTelemetry with SigNoz OTLP exporter, trace propagation, and Temporal interceptors:

```java:src/main/java/helloworld/config/SignozTelemetryUtils.java
package helloworld.config;

import io.opentelemetry.api.OpenTelemetry;
import io.opentelemetry.api.metrics.Meter;
import io.opentelemetry.api.trace.Tracer;
import io.opentelemetry.api.trace.propagation.W3CTraceContextPropagator;
import io.opentelemetry.context.propagation.ContextPropagators;
import io.opentelemetry.sdk.OpenTelemetrySdk;
import io.temporal.common.interceptors.WorkerInterceptor;
import io.temporal.common.interceptors.WorkflowClientInterceptor;
import com.uber.m3.tally.Scope;
import java.util.logging.Level;
import java.util.logging.Logger;

public final class SignozTelemetryUtils {
    private static final Logger logger = Logger.getLogger(SignozTelemetryUtils.class.getName());
    private static volatile boolean isInitialized = false;
    private static volatile Tracer tracer;
    private static volatile Meter meter;

    public static synchronized void initializeTelemetry() {
        if (isInitialized) {
            logger.info("OpenTelemetry already initialized");
            return;
        }

        try {
            logger.info("Configuring OpenTelemetry with endpoint: " + OpenTelemetryConfig.getEndpoint());

            System.setProperty("otel.exporter.otlp.protocol", "grpc");
            System.setProperty("otel.exporter.otlp.endpoint", OpenTelemetryConfig.getEndpoint());

            OpenTelemetrySdk sdk = OpenTelemetrySdk.builder()
                .setTracerProvider(TracingExporter.createTracerProvider())
                .setMeterProvider(MetricsExporter.createMeterProvider())
                .setPropagators(ContextPropagators.create(W3CTraceContextPropagator.getInstance()))
                .build();

            OpenTelemetryConfig.setOpenTelemetry(sdk);
            isInitialized = true;

            Runtime.getRuntime().addShutdownHook(new Thread(() -> {
                try {
                    logger.info("Starting OpenTelemetry shutdown...");
                    TracingExporter.shutdown();
                    MetricsExporter.shutdown();
                    logger.info("OpenTelemetry shutdown completed");
                } catch (Exception e) {
                    logger.log(Level.SEVERE, "Error during OpenTelemetry shutdown", e);
                }
            }));

            logger.info("OpenTelemetry initialized successfully");
        } catch (Exception e) {
            logger.log(Level.SEVERE, "Error configuring OpenTelemetry", e);
            throw new RuntimeException("Failed to configure OpenTelemetry", e);
        }
    }

    public static OpenTelemetry getOpenTelemetry() {
        ensureInitialized();
        return OpenTelemetryConfig.getOpenTelemetry();
    }

    public static synchronized Tracer getTracer() {
        if (tracer == null) {
            tracer = getOpenTelemetry().getTracer(SignozTelemetryUtils.class.getName());
        }
        return tracer;
    }

    public static synchronized Meter getMeter() {
        if (meter == null) {
            meter = getOpenTelemetry().getMeter(SignozTelemetryUtils.class.getName());
        }
        return meter;
    }

    public static Scope getMetricsScope() {
        ensureInitialized();
        return MetricsExporter.getMetricsScope();
    }

    public static WorkerInterceptor getWorkerInterceptor() {
        ensureInitialized();
        return TracingExporter.getWorkerInterceptor();
    }

    public static WorkflowClientInterceptor getClientInterceptor() {
        ensureInitialized();
        return TracingExporter.getClientInterceptor();
    }

    private static void ensureInitialized() {
        if (!isInitialized) {
            throw new IllegalStateException("OpenTelemetry not initialized. Call initializeTelemetry() first.");
        }
    }

    private SignozTelemetryUtils() {
    }
}
```

### Step 3: Configure OpenTelemetry Settings

Create `OpenTelemetryConfig.java` to manage OpenTelemetry configuration including service attributes, resource settings, and endpoint configuration. This class will be used by the telemetry utilities to initialize the OpenTelemetry SDK.

```java:src/main/java/helloworld/config/OpenTelemetryConfig.java
package helloworld.config;

import io.opentelemetry.api.OpenTelemetry;
import io.opentelemetry.api.common.Attributes;
import io.opentelemetry.api.common.AttributeKey;
import io.opentelemetry.sdk.OpenTelemetrySdk;
import io.opentelemetry.sdk.resources.Resource;
import java.util.logging.Logger;

public final class OpenTelemetryConfig {
    private static final Logger logger = Logger.getLogger(OpenTelemetryConfig.class.getName());

    public static final String DEFAULT_SIGNOZ_ENDPOINT = "http://localhost:4317";

    public static final AttributeKey<String> SERVICE_NAMESPACE = AttributeKey.stringKey("service.namespace");
    public static final AttributeKey<String> DEPLOYMENT_ENVIRONMENT = AttributeKey.stringKey("deployment.environment");

    private static final String ENV_OTEL_ENDPOINT = "OTEL_EXPORTER_OTLP_ENDPOINT";
    private static final String ENV_ENVIRONMENT = "OTEL_ENVIRONMENT";

    private static volatile OpenTelemetry openTelemetry;

    public static OpenTelemetry getOpenTelemetry() {
        if (openTelemetry == null) {
            throw new IllegalStateException("OpenTelemetry not initialized. Call initialize() first.");
        }
        return openTelemetry;
    }

    public static Resource createResource() {
        String environment = System.getenv().getOrDefault(ENV_ENVIRONMENT, "development");

        Resource baseResource = Resource.getDefault();
        Resource customResource = Resource.create(Attributes.of(
            SERVICE_NAMESPACE, "default",
            DEPLOYMENT_ENVIRONMENT, environment
        ));

        logger.info("Creating resource with environment: " + environment);
        return baseResource.merge(customResource);
    }

    public static String getEndpoint() {
        return System.getenv().getOrDefault(ENV_OTEL_ENDPOINT, DEFAULT_SIGNOZ_ENDPOINT);
    }

    protected static synchronized void setOpenTelemetry(OpenTelemetrySdk sdk) {
        if (openTelemetry != null) {
            throw new IllegalStateException("OpenTelemetry already initialized");
        }
        openTelemetry = sdk;
    }

    private OpenTelemetryConfig() {
    }
}
```

### Step 4: Set Up Trace Export

Create `TracingExporter.java` to configure trace export to SigNoz with OTLP/gRPC, batch processing, and Temporal tracing:

```java:src/main/java/helloworld/config/TracingExporter.java
package helloworld.config;

import io.opentelemetry.exporter.otlp.trace.OtlpGrpcSpanExporter;
import io.opentelemetry.sdk.trace.SdkTracerProvider;
import io.opentelemetry.sdk.trace.export.BatchSpanProcessor;
import io.temporal.common.interceptors.WorkerInterceptor;
import io.temporal.common.interceptors.WorkflowClientInterceptor;
import io.temporal.opentracing.OpenTracingClientInterceptor;
import io.temporal.opentracing.OpenTracingOptions;
import io.temporal.opentracing.OpenTracingSpanContextCodec;
import io.temporal.opentracing.OpenTracingWorkerInterceptor;
import io.opentelemetry.opentracingshim.OpenTracingShim;
import java.util.logging.Logger;
import java.util.concurrent.TimeUnit;

public class TracingExporter {
    private static final Logger logger = Logger.getLogger(TracingExporter.class.getName());
    private static OpenTracingOptions openTracingOptions;
    private static BatchSpanProcessor spanProcessor;

    public static synchronized OpenTracingOptions getOpenTracingOptions() {
        if (openTracingOptions == null) {
            openTracingOptions = OpenTracingOptions.newBuilder()
                .setTracer(OpenTracingShim.createTracerShim(OpenTelemetryConfig.getOpenTelemetry()))
                .setSpanContextCodec(OpenTracingSpanContextCodec.TEXT_MAP_CODEC)
                .build();
        }
        return openTracingOptions;
    }

    public static WorkerInterceptor getWorkerInterceptor() {
        return new OpenTracingWorkerInterceptor(getOpenTracingOptions());
    }

    public static WorkflowClientInterceptor getClientInterceptor() {
        return new OpenTracingClientInterceptor(getOpenTracingOptions());
    }

    public static SdkTracerProvider createTracerProvider() {
        String endpoint = OpenTelemetryConfig.getEndpoint();

        OtlpGrpcSpanExporter spanExporter = OtlpGrpcSpanExporter.builder()
            .setEndpoint(endpoint)
            .addHeader("signoz-debug", "true")
            .setTimeout(java.time.Duration.ofSeconds(30))
            .build();

        spanProcessor = BatchSpanProcessor.builder(spanExporter)
            .setScheduleDelay(java.time.Duration.ofMillis(100))
            .setMaxQueueSize(2048)
            .setMaxExportBatchSize(512)
            .build();

        return SdkTracerProvider.builder()
            .addSpanProcessor(spanProcessor)
            .setResource(OpenTelemetryConfig.createResource())
            .build();
    }

    public static void shutdown() {
        if (spanProcessor != null) {
            try {
                logger.info("Shutting down span processor...");
                spanProcessor.forceFlush().join(10, TimeUnit.SECONDS);
                spanProcessor.shutdown().join(10, TimeUnit.SECONDS);
                logger.info("Span processor shutdown completed");
            } catch (Exception e) {
                logger.severe("Error during span processor shutdown: " + e.getMessage());
            }
        }
    }

    private TracingExporter() {
    }
}
```

### Step 5: Configure Worker with Tracing

Update your Temporal Worker to use the initialize OpenTelemetry for traces:

```java:src/main/java/helloworld/workers/HelloWorldWorker.java
package helloworld.workers;

import helloworld.config.TemporalConfig;
import helloworld.config.SignozTelemetryUtils;
import helloworld.workflows.impl.HelloWorldWorkflowImpl;
import io.temporal.worker.Worker;
import io.temporal.worker.WorkerFactory;
import io.temporal.worker.WorkerFactoryOptions;
import io.temporal.client.WorkflowClient;
import io.temporal.client.WorkflowClientOptions;
import io.temporal.serviceclient.WorkflowServiceStubsOptions;
import java.util.logging.Logger;
import java.util.logging.Level;

public class HelloWorldWorker implements AutoCloseable {
    private static final Logger logger = Logger.getLogger(HelloWorldWorker.class.getName());
    private final WorkerFactory factory;
    private final Worker worker;

    public HelloWorldWorker() {
        try {
            // Initialize OpenTelemetry with SigNoz configuration
            SignozTelemetryUtils.initializeTelemetry();
            logger.info("OpenTelemetry initialized successfully");

            // Configure service stubs with metrics
            WorkflowServiceStubsOptions stubOptions = WorkflowServiceStubsOptions.newBuilder()
                .setMetricsScope(SignozTelemetryUtils.getMetricsScope())
                .build();

            // Configure worker factory with tracing interceptor
            WorkerFactoryOptions factoryOptions = WorkerFactoryOptions.newBuilder()
                .setWorkerInterceptors(SignozTelemetryUtils.getWorkerInterceptor())
                .build();

            // Create workflow client with tracing interceptor
            WorkflowClient client = WorkflowClient.newInstance(
                TemporalConfig.getWorkflowServiceStubs(stubOptions),
                WorkflowClientOptions.newBuilder()
                    .setInterceptors(SignozTelemetryUtils.getClientInterceptor())
                    .build()
            );

            // Create factory with configured options
            this.factory = WorkerFactory.newInstance(client, factoryOptions);

            // Create and configure worker
            this.worker = factory.newWorker(TemporalConfig.getTaskQueue());
            this.worker.registerWorkflowImplementationTypes(HelloWorldWorkflowImpl.class);
            this.worker.registerActivitiesImplementations(new HelloWorldActivityImpl());
            
            logger.info("Worker initialized with OpenTelemetry integration");
        } catch (Exception e) {
            logger.log(Level.SEVERE, "Failed to initialize worker with OpenTelemetry", e);
            throw new RuntimeException("Worker initialization failed", e);
        }
    }

    // Additional methods for worker lifecycle management (start, close)
    // ...
}
```

### Step 6: Configure Workflow Starter
Update your Temporal Workflow Starter to use the initialize OpenTelemetry for traces:

```java:src/main/java/helloworld/main/HelloWorldStarter.java
package helloworld.main;

import helloworld.config.TemporalConfig;
import helloworld.config.SignozTelemetryUtils;
import helloworld.config.TracingExporter;
import helloworld.workflows.HelloWorldWorkflow;
import io.temporal.client.WorkflowClient;
import io.temporal.client.WorkflowClientOptions;
import io.temporal.client.WorkflowOptions;
import io.temporal.common.RetryOptions;
import io.temporal.serviceclient.WorkflowServiceStubsOptions;
import io.opentelemetry.api.trace.Span;
import io.opentelemetry.api.trace.StatusCode;
import io.opentelemetry.api.trace.Tracer;
import io.opentelemetry.context.Scope;
import java.time.Duration;
import java.util.UUID;

public class HelloWorldStarter {
    private final WorkflowClient client;
    private final Tracer tracer;

    public HelloWorldStarter() {
        // Initialize OpenTelemetry
        SignozTelemetryUtils.initializeTelemetry();
        this.tracer = SignozTelemetryUtils.getTracer();

        // Configure service stubs with OpenTelemetry
        WorkflowServiceStubsOptions stubOptions = WorkflowServiceStubsOptions.newBuilder()
            .setMetricsScope(SignozTelemetryUtils.getMetricsScope())
            .build();

        // Configure client with OpenTelemetry interceptor
        WorkflowClientOptions clientOptions = WorkflowClientOptions.newBuilder()
            .setInterceptors(SignozTelemetryUtils.getClientInterceptor())
            .build();

        // Create client with configured options
        this.client = TemporalConfig.getWorkflowClient(stubOptions, clientOptions);
    }

    public void runWorkflow(String name) {
        // Create workflow span for tracing
        Span workflowSpan = tracer.spanBuilder("StartWorkflow")
            .setAttribute("workflow.name", "HelloWorldWorkflow")
            .setAttribute("workflow.input", name)
            .setAttribute("workflow.type", "temporal")
            .startSpan();

        try (Scope scope = workflowSpan.makeCurrent()) {
            // Configure workflow options with retry policy
            WorkflowOptions options = WorkflowOptions.newBuilder()
                .setTaskQueue(TemporalConfig.getTaskQueue())
                .setWorkflowId("hello-world-" + UUID.randomUUID())
                .setRetryOptions(RetryOptions.newBuilder()
                    .setInitialInterval(Duration.ofSeconds(1))
                    .setMaximumInterval(Duration.ofSeconds(10))
                    .setBackoffCoefficient(2.0)
                    .setMaximumAttempts(3)
                    .build())
                .build();

            // Execute workflow with tracing
            HelloWorldWorkflow workflow = client.newWorkflowStub(HelloWorldWorkflow.class, options);
            String result = workflow.sayHello(name);
            
            workflowSpan.setStatus(StatusCode.OK);
            System.out.println("Workflow result: " + result);
        } catch (Exception e) {
            workflowSpan.recordException(e);
            workflowSpan.setStatus(StatusCode.ERROR);
            throw new RuntimeException("Workflow execution failed", e);
        } finally {
            workflowSpan.end();
            TracingExporter.shutdown();
        }
    }

    // Additional methods and main entry point
    // ...
}
```

### Step 7: Configure Environment
Set up your environment variables for Signoz.

```bash
# SigNoz endpoint
OTEL_EXPORTER_OTLP_ENDPOINT=http://localhost:4317

# Set service name and other attributes
OTEL_RESOURCE_ATTRIBUTES="service.name=temporal-hello-world"
```

### Step 8: Run Application

1. Start the worker with tracing enabled:
```bash
mvn exec:java -Dexec.mainClass="helloworld.workers.HelloWorldWorker"
```

2. Execute workflows to generate traces:
```bash
mvn exec:java -Dexec.mainClass="helloworld.main.HelloWorldStarter"
```

</TabItem>

<TabItem value="typescript" label="TypeScript">

### Step 1: Add OpenTelemetry Dependencies

Add the following dependencies to your `package.json`:

```json
{
  "dependencies": {
    "@opentelemetry/api": "^1.7.0",
    "@opentelemetry/auto-instrumentations-node": "^0.40.3",
    "@opentelemetry/core": "^1.18.1",
    "@opentelemetry/exporter-trace-otlp-grpc": "^0.44.0",
    "@opentelemetry/exporter-metrics-otlp-grpc": "^0.44.0",
    "@opentelemetry/resources": "^1.18.1",
    "@opentelemetry/sdk-metrics": "^1.18.1",
    "@opentelemetry/sdk-node": "^0.44.0",
    "@opentelemetry/sdk-trace-node": "^1.18.1",
    "@opentelemetry/semantic-conventions": "^1.18.1",
    "@temporalio/client": "^1.8.6",
    "@temporalio/worker": "^1.8.6",
    "@temporalio/workflow": "^1.8.6"
  }
}
```

### Step 2: Configure OpenTelemetry Utilities

Create `signozTelemetryUtils.ts` to manage OpenTelemetry SDK lifecycle and provide access to tracer and meter instances for SigNoz integration:

```typescript:src/config/signozTelemetryUtils.ts
import { diag, trace, metrics, Tracer, Meter } from '@opentelemetry/api';
import { NodeSDK } from '@opentelemetry/sdk-node';

// Store SDK instances for direct access
let sdkInstance: NodeSDK | null = null;
let tracerInstance: Tracer | null = null;
let meterInstance: Meter | null = null;

// Get or create tracer instance
export function getTracer(): Tracer {
    if (!tracerInstance) {
        tracerInstance = trace.getTracer('temporal-hello-world');
    }
    return tracerInstance;
}

// Get or create meter instance
export function getMeter(): Meter {
    if (!meterInstance) {
        meterInstance = metrics.getMeter('temporal-hello-world');
    }
    return meterInstance;
}

// Store the SDK instance
export function setOpenTelemetrySdk(sdk: NodeSDK): void {
    sdkInstance = sdk;
}

// Access the SDK instance
export function getOpenTelemetrySdk(): NodeSDK | null {
    return sdkInstance;
}

// Ensure all telemetry data is exported before shutdown
export async function forceSpanExport(): Promise<boolean> {
    if (!sdkInstance) {
        return false;
    }
    
    const timeoutPromise = new Promise<boolean>((resolve) => {
        setTimeout(() => resolve(false), 3000);
    });
    
    const shutdownPromise = sdkInstance.shutdown()
        .then(() => true)
        .catch(() => false);
    
    return Promise.race([shutdownPromise, timeoutPromise]);
}
```

### Step 3: Configure OpenTelemetry Trace Exporter

Create `tracingExporter.ts` to configure the trace exporter:

```typescript:src/config/tracingExporter.ts
import { diag } from '@opentelemetry/api';
import { OTLPTraceExporter } from '@opentelemetry/exporter-trace-otlp-grpc';

export function getTracingExporter(): OTLPTraceExporter {
    const endpoint = process.env.OTEL_EXPORTER_OTLP_ENDPOINT || 'http://localhost:4317';
    diag.info(`[TELEMETRY] Configuring trace exporter with gRPC protocol: ${endpoint}`);
    
    return new OTLPTraceExporter({
        url: endpoint, // For gRPC, we don't need to specify the path
    });
}

export function configureTracingEnvironment(): void {
    // Configure environment variables for tracing
    process.env.OTEL_TRACES_EXPORTER = 'otlp';
    process.env.OTEL_TRACES_SAMPLER = 'always_on';
}
```

### Step 4: Configure OpenTelemetry SDK

Create `opentelemetryConfig.ts` to initialize the OpenTelemetry SDK:

```typescript:src/config/opentelemetryConfig.ts
import { NodeSDK } from '@opentelemetry/sdk-node';
import { Resource } from '@opentelemetry/resources';
import { ATTR_SERVICE_NAME } from '@opentelemetry/semantic-conventions';
import { diag, DiagConsoleLogger, DiagLogLevel } from '@opentelemetry/api';
import { CompositePropagator, W3CTraceContextPropagator, W3CBaggagePropagator } from '@opentelemetry/core';
import { getNodeAutoInstrumentations } from '@opentelemetry/auto-instrumentations-node';
import { getMetricsReader } from './metricsExporter';
import { getTracingExporter, configureTracingEnvironment } from './tracingExporter';
import { configureMetricsEnvironment } from './metricsExporter';
import { setOpenTelemetrySdk } from './signozTelemetryUtils';

// Define incubating semantic convention attributes
const ATTR_SERVICE_NAMESPACE = 'service.namespace';
const ATTR_DEPLOYMENT_ENVIRONMENT = 'deployment.environment';

// Logger configuration state
let loggerConfigured = false;

function configureLogger(logLevel: DiagLogLevel = DiagLogLevel.INFO): void {
    if (!loggerConfigured) {
        diag.setLogger(new DiagConsoleLogger(), logLevel);
        loggerConfigured = true;
        diag.info('[TELEMETRY] OpenTelemetry logger configured');
    }
}

function configureEnvironmentVariables(serviceName: string): void {
    // Configure core environment variables
    process.env.OTEL_SERVICE_NAME = serviceName;
    process.env.OTEL_EXPORTER_OTLP_PROTOCOL = 'grpc';
    process.env.OTEL_PROPAGATORS = 'tracecontext,baggage';
    process.env.OTEL_LOGS_EXPORTER = 'none';
    
    // Configure tracing and metrics
    configureTracingEnvironment();
    configureMetricsEnvironment();
    
    // Log environment configuration for debugging
    diag.debug('[TELEMETRY] Environment variables:', {
        OTEL_EXPORTER_OTLP_ENDPOINT: process.env.OTEL_EXPORTER_OTLP_ENDPOINT || 'http://localhost:4317',
        OTEL_EXPORTER_OTLP_PROTOCOL: process.env.OTEL_EXPORTER_OTLP_PROTOCOL,
        OTEL_RESOURCE_ATTRIBUTES: process.env.OTEL_RESOURCE_ATTRIBUTES,
        OTEL_SERVICE_NAME: process.env.OTEL_SERVICE_NAME,
    });
}

function createServiceResource(serviceName: string): Resource {
    return Resource.default().merge(
        new Resource({
            [ATTR_SERVICE_NAME]: serviceName,
            [ATTR_SERVICE_NAMESPACE]: 'default',
            [ATTR_DEPLOYMENT_ENVIRONMENT]: process.env.OTEL_ENVIRONMENT || 'development',
        })
    );
}

export async function initOpenTelemetry(serviceName: string): Promise<NodeSDK> {
    // Configure the logger first
    configureLogger();
    
    diag.info('[TELEMETRY] Initializing OpenTelemetry for service:', serviceName);

    // Configure environment variables
    configureEnvironmentVariables(serviceName);

    try {
        // Create and configure the SDK
        const sdk = new NodeSDK({
            resource: createServiceResource(serviceName),
            traceExporter: getTracingExporter(),
            // Use as any to bypass type conflicts between different @opentelemetry/sdk-metrics versions
            metricReader: getMetricsReader() as any,
            textMapPropagator: new CompositePropagator({
                propagators: [
                    new W3CTraceContextPropagator(),
                    new W3CBaggagePropagator()
                ],
            }),
            instrumentations: [
                getNodeAutoInstrumentations({
                    '@opentelemetry/instrumentation-http': { enabled: true },
                    '@opentelemetry/instrumentation-grpc': { enabled: true },
                }),
            ]
        });

        // Store SDK instance in utilities
        setOpenTelemetrySdk(sdk);

        // Start the SDK
        await sdk.start();
        diag.info('[TELEMETRY] OpenTelemetry SDK initialized successfully for', serviceName);

        // Register shutdown handler for clean exit
        registerShutdownHandler(sdk);

        return sdk;
    } catch (error) {
        diag.error('[TELEMETRY] Failed to initialize OpenTelemetry:', error instanceof Error ? error.message : String(error));
        throw error;
    }
}

function registerShutdownHandler(sdk: NodeSDK): void {
    const shutdown = async () => {
        diag.info('[TELEMETRY] Shutting down OpenTelemetry SDK');
        
        try {
            const shutdownPromise = sdk.shutdown();
            const timeoutPromise = new Promise((_, reject) => 
                setTimeout(() => reject(new Error('Shutdown timed out')), 5000)
            );
            
            await Promise.race([shutdownPromise, timeoutPromise]);
            diag.info('[TELEMETRY] OpenTelemetry SDK shut down successfully');
        } catch (error) {
            diag.error('[TELEMETRY] Error shutting down OpenTelemetry SDK:', 
                error instanceof Error ? error.message : String(error));
        }
    };

    // Handle various termination signals
    process.on('SIGTERM', shutdown);
    process.on('SIGINT', shutdown);
    
    // Handle uncaught errors
    process.on('uncaughtException', async (error) => {
        diag.error('[TELEMETRY] Uncaught exception, shutting down telemetry before exit:', error);
        await shutdown();
    });
}
```

### Step 5: Configure Temporal Worker with Tracing

Create a worker with OpenTelemetry integration:

```typescript:src/worker.ts
import { trace, SpanKind, context, SpanStatusCode } from '@opentelemetry/api';
import { getTracer, forceSpanExport } from './config/signozTelemetryUtils';

// Initialize tracer
const tracer = getTracer();

// Create main worker span
const executeWorkflowSpan = tracer.startSpan('ExecuteWorkflow', {
  kind: SpanKind.INTERNAL,
  attributes: {
    'worker.type': 'temporal',
    'service.name': 'temporal-hello-world',
    'workflow.task_queue': DEFAULT_TASK_QUEUE,
    'temporal.component': 'worker'
  }
});

// Make the span active for the worker lifetime
const workerContext = trace.setSpan(context.active(), executeWorkflowSpan);

await context.with(workerContext, async () => {
  try {
    // Worker implementation...
    
    // Graceful shutdown handling
    const shutdown = async () => {
      // Worker shutdown logic...
      executeWorkflowSpan.end();
      await forceSpanExport();
    };
  } catch (err) {
    // Error handling with span
    executeWorkflowSpan.setStatus({
      code: SpanStatusCode.ERROR,
      message: err instanceof Error ? err.message : String(err)
    });
    executeWorkflowSpan.end();
    await forceSpanExport();
  }
});
```

### Step 6: Configure Workflow Client with Tracing

Create a client with OpenTelemetry tracing:

```typescript:src/client.ts
import { Client, Connection } from '@temporalio/client';
import { initOpenTelemetry } from './config/opentelemetryConfig';
import { forceSpanExport, getTracer, getMeter } from './config/signozTelemetryUtils';
import { DEFAULT_TASK_QUEUE } from './config/temporalConfig';
import { trace, SpanKind, context, SpanStatusCode } from '@opentelemetry/api';

async function run() {
  // Initialize OpenTelemetry
  console.log('[STARTER] Initializing OpenTelemetry...');
  await initOpenTelemetry('temporal-hello-world');

  // Get tracer and meter instances for instrumentation
  const tracer = getTracer();
  const meter = getMeter();

  // Create workflow execution counter
  const workflowCounter = meter.createCounter('workflow.executions', {
    description: 'Number of workflow executions'
  });

  // Create main span for the entire workflow execution process
  const startWorkflowSpan = tracer.startSpan('StartWorkflow', {
    kind: SpanKind.INTERNAL,
    attributes: {
      'workflow.type': 'temporal',
      'service.name': 'temporal-hello-world',
      'temporal.component': 'starter',
    }
  });

  // Make the span active for this context
  const starterContext = trace.setSpan(context.active(), startWorkflowSpan);
  
  try {
    await context.with(starterContext, async () => {
      // ... Temporal connection logic ...
      
      const workflowId = `hello-world-${generateId()}`;
      
      // Create child spans for the specific workflow execution
      const executeWorkflowSpan = tracer.startSpan('ExecuteWorkflow', {
        kind: SpanKind.INTERNAL,
        attributes: {
          'workflow.id': workflowId,
          'workflow.name': 'HelloWorldWorkflow',
          'workflow.task_queue': taskQueue,
          'temporal.workflow.type': 'HelloWorldWorkflow'
        }
      });

      // Track the execution with our counter
      workflowCounter.add(1, {
        'workflow.name': 'HelloWorldWorkflow',
        'workflow.task_queue': taskQueue
      });

      try {
        // ... Workflow execution logic ...

        // Record successful outcome in our spans
        executeWorkflowSpan.setStatus({ code: SpanStatusCode.OK });
        executeWorkflowSpan.setAttribute('workflow.status', 'completed');
        executeWorkflowSpan.setAttribute('workflow.result', result);
        executeWorkflowSpan.end();
        
      } catch (err) {
        // Record error in our spans
        executeWorkflowSpan.setStatus({
          code: SpanStatusCode.ERROR,
          message: err instanceof Error ? err.message : String(err)
        });
        executeWorkflowSpan.setAttribute('workflow.status', 'failed');
        executeWorkflowSpan.end();
      }
    });
  } catch (err) {
    startWorkflowSpan.setStatus({
      code: SpanStatusCode.ERROR,
      message: err instanceof Error ? err.message : String(err)
    });
  } finally {
    // Always end the main span and force export
    startWorkflowSpan.end();
    await forceSpanExport();
  }
}

run();
```

### Step 7: Define Workflows with OpenTelemetry Integration

Workflows don't require direct OpenTelemetry instrumentation because tracing context is automatically propagated by Temporal's infrastructure.

```typescript:src/workflows/impl/helloWorldWorkflowImpl.ts
import { proxyActivities } from '@temporalio/workflow';
import { HelloWorldWorkflow } from '../interfaces/helloWorldWorkflow';
import * as activities from '../../activities/index';

// Activities are proxied through Temporal which maintains tracing context
const { formatName, generateGreeting, addTimestamp } = proxyActivities<typeof activities>({
  startToCloseTimeout: '1 minute',
});

export class HelloWorldWorkflowImpl implements HelloWorldWorkflow {
  async sayHello(name: string): Promise<string> {
    // Each activity call is automatically traced through context propagation
    // The spans created by activities are connected to the parent spans created in the worker
    const formattedName = await formatName(name);
    const greeting = await generateGreeting(formattedName);
    const timestampedGreeting = await addTimestamp(greeting);
    
    return timestampedGreeting;
  }
}

// Workflow function that Temporal executes
export async function sayHello(name: string): Promise<string> {
  const workflow = new HelloWorldWorkflowImpl();
  return workflow.sayHello(name);
}
```

### Step 8: Configure Environment Variables

```bash
# SigNoz endpoint
OTEL_EXPORTER_OTLP_ENDPOINT=http://localhost:4317

# Set service name and other attributes
OTEL_RESOURCE_ATTRIBUTES="service.name=temporal-hello-world"
```

### Step 9: Add Basic Temporal Configuration

```typescript:src/config/temporalConfig.ts
// Default Temporal configuration
export const DEFAULT_TASK_QUEUE = 'hello-world-task-queue';
```

### Step 10: Run Application

1. Start the worker with tracing enabled:
```bash
npm run worker
```

2. Execute a workflow to generate traces:
```bash
npm run workflow
```

</TabItem>

<TabItem value="go" label="Go">

### Step 1: Add OpenTelemetry Dependencies

Add the following dependencies to your `go.mod`:

```go
require (
	go.opentelemetry.io/otel v1.24.0
	go.opentelemetry.io/otel/exporters/otlp/otlpmetric/otlpmetricgrpc v1.24.0
	go.opentelemetry.io/otel/exporters/otlp/otlptrace/otlptracegrpc v1.24.0
	go.opentelemetry.io/otel/metric v1.24.0
	go.opentelemetry.io/otel/sdk v1.24.0
	go.opentelemetry.io/otel/sdk/metric v1.24.0
	go.opentelemetry.io/otel/trace v1.24.0
	go.temporal.io/api v1.24.0
	go.temporal.io/sdk v1.25.1
	go.temporal.io/sdk/contrib/opentelemetry v0.3.0
)
```

### Step 2: Configure OpenTelemetry

Create `signoz_telemetry_utils.go` to coordinate the OpenTelemetry components:

```go:internal/helloworld/config/signoz_telemetry_utils.go
package config

import (
	"context"
	"fmt"
	"log"
	"time"

	"go.opentelemetry.io/otel"
)

// SignozTelemetryUtils coordinates all telemetry components
type SignozTelemetryUtils struct {
	otelConfig *OpenTelemetryConfig
}

// NewSignozTelemetryUtils creates a new telemetry configuration
func NewSignozTelemetryUtils() *SignozTelemetryUtils {
	return &SignozTelemetryUtils{
		otelConfig: NewOpenTelemetryConfig(),
	}
}

// InitProvider initializes all telemetry providers
func (c *SignozTelemetryUtils) InitProvider(ctx context.Context) (func(), error) {
	// Create resource
	res, err := c.otelConfig.CreateResource(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed to create resource: %w", err)
	}

	// Get TLS credentials
	creds := c.otelConfig.GetTLSCredentials()

	// Initialize metrics
	metricsConfig := &MetricsExporterConfig{
		ServiceName: c.otelConfig.ServiceName,
		Environment: c.otelConfig.Environment,
		Endpoint:    c.otelConfig.Endpoint,
		Headers:     c.otelConfig.Headers,
		TLSCreds:    creds,
	}
	meterProvider, err := NewMetricsExporter(ctx, metricsConfig, res)
	if err != nil {
		return nil, fmt.Errorf("failed to create metrics exporter: %w", err)
	}

	// Set global meter provider
	otel.SetMeterProvider(meterProvider)

	// Initialize tracing
	tracingConfig := &TracingExporterConfig{
		ServiceName: c.otelConfig.ServiceName,
		Environment: c.otelConfig.Environment,
		Endpoint:    c.otelConfig.Endpoint,
		Headers:     c.otelConfig.Headers,
		TLSCreds:    creds,
	}
	tracerProvider, err := NewTracingExporter(ctx, tracingConfig, res)
	if err != nil {
		return nil, fmt.Errorf("failed to create tracer provider: %w", err)
	}

	// Set global tracer provider
	otel.SetTracerProvider(tracerProvider)

	// Setup propagator
	SetupPropagator()

	// ...

	// Return cleanup function
	cleanup := func() {
		shutdownCtx, cancel := context.WithTimeout(context.Background(), 30*time.Second)
		defer cancel()

		if err := tracerProvider.Shutdown(shutdownCtx); err != nil {
			log.Printf("[ERROR] Error shutting down tracer provider: %v\n", err)
		}

		if err := meterProvider.Shutdown(shutdownCtx); err != nil {
			log.Printf("[ERROR] Error shutting down meter provider: %v\n", err)
		}
	}

	return cleanup, nil
}
```

### Step 3: Configure OpenTelemetry Settings

Create `opentelemetry_config.go` to manage OpenTelemetry configuration:

```go:internal/helloworld/config/opentelemetry_config.go
package config

import (
	"context"
	"fmt"
	"os"
	"strings"

	"go.opentelemetry.io/otel"
	"go.opentelemetry.io/otel/propagation"
	"go.opentelemetry.io/otel/sdk/resource"
	semconv "go.opentelemetry.io/otel/semconv/v1.24.0"
	"google.golang.org/grpc/credentials"
	"google.golang.org/grpc/credentials/insecure"
)

// OpenTelemetryConfig holds OpenTelemetry configuration
type OpenTelemetryConfig struct {
	ServiceName string
	Environment string
	Endpoint    string
	Headers     map[string]string
	UseTLS      bool
}

// NewOpenTelemetryConfig creates a new OpenTelemetry configuration
func NewOpenTelemetryConfig() *OpenTelemetryConfig {
	endpoint := os.Getenv("OTEL_EXPORTER_OTLP_ENDPOINT")
	if endpoint == "" {
		endpoint = "localhost:4317"
	} else {
		// Strip http:// or https:// prefix
		endpoint = strings.TrimPrefix(strings.TrimPrefix(endpoint, "http://"), "https://")
	}

	return &OpenTelemetryConfig{
		ServiceName: "temporal-hello-world",
		Environment: "development",
		Endpoint:    endpoint,
		Headers:     parseHeaders(),
		UseTLS:      false,
	}
}

// CreateResource creates a new resource with common attributes
func (c *OpenTelemetryConfig) CreateResource(ctx context.Context) (*resource.Resource, error) {
	hostname, _ := os.Hostname()
	return resource.New(ctx,
		resource.WithAttributes(
			semconv.ServiceName(c.ServiceName),
			semconv.ServiceVersion("1.0.0"),
			semconv.DeploymentEnvironment(c.Environment),
			semconv.HostName(hostname),
			semconv.ServiceInstanceID(fmt.Sprintf("%s-%d", hostname, os.Getpid())),
		),
		resource.WithSchemaURL(semconv.SchemaURL),
	)
}

// GetTLSCredentials returns the appropriate TLS credentials
func (c *OpenTelemetryConfig) GetTLSCredentials() credentials.TransportCredentials {
	if c.UseTLS {
		return credentials.NewClientTLSFromCert(nil, "")
	}
	return insecure.NewCredentials()
}

// SetupPropagator configures the global propagator
func SetupPropagator() {
	otel.SetTextMapPropagator(propagation.NewCompositeTextMapPropagator(
		propagation.TraceContext{},
		propagation.Baggage{},
	))
}

// parseHeaders parses OTEL_EXPORTER_OTLP_HEADERS environment variable
func parseHeaders() map[string]string {
	headers := make(map[string]string)
	headerStr := os.Getenv("OTEL_EXPORTER_OTLP_HEADERS")
	if headerStr != "" {
		// Parse headers in format "key1=value1,key2=value2"
		pairs := strings.Split(headerStr, ",")
		for _, pair := range pairs {
			kv := strings.SplitN(pair, "=", 2)
			if len(kv) == 2 {
				headers[strings.TrimSpace(kv[0])] = strings.TrimSpace(kv[1])
			}
		}
	}
	return headers
}
```

### Step 4: Set Up Trace Export

Create `tracing_exporter.go` to configure the OTLP trace exporter:

```go:internal/helloworld/config/tracing_exporter.go
package config
import (
    "context"
    "fmt"
    "time"
    "go.opentelemetry.io/otel/exporters/otlp/otlptrace/otlptracegrpc"
    "go.opentelemetry.io/otel/sdk/resource"
    sdktrace "go.opentelemetry.io/otel/sdk/trace"
    "google.golang.org/grpc/credentials"
)
// TracingExporterConfig holds configuration for tracing export
type TracingExporterConfig struct {
    ServiceName string
    Environment string
    Endpoint string
    Headers map[string] string
    TLSCreds credentials.TransportCredentials
}
// NewTracingExporter creates and configures the tracing exporter
func NewTracingExporter(ctx context.Context, cfg TracingExporterConfig, res resource.Resource)(sdktrace.TracerProvider, error) {
        // Configure trace exporter
        exporter, err: = otlptracegrpc.New(ctx,
            otlptracegrpc.WithEndpoint(cfg.Endpoint),
            otlptracegrpc.WithHeaders(cfg.Headers),
            otlptracegrpc.WithTLSCredentials(cfg.TLSCreds),
            otlptracegrpc.WithRetry(otlptracegrpc.RetryConfig {
                Enabled: true,
                InitialInterval: 1 * time.Second,
                MaxInterval: 5 * time.Second,
                MaxElapsedTime: 30 * time.Second,
            }),
        )
        if err != nil {
                return nil, fmt.Errorf("failed to create trace exporter: %w", err)
            }
            // Configure tracer provider with more frequent batching
        tracerProvider: = sdktrace.NewTracerProvider(
            sdktrace.WithResource(res),
            sdktrace.WithSampler(sdktrace.AlwaysSample()),
            sdktrace.WithBatcher(exporter,
                sdktrace.WithBatchTimeout(5 time.Second),
                sdktrace.WithMaxExportBatchSize(512),
                sdktrace.WithMaxQueueSize(2048),
            ),
        )
        return tracerProvider, nil
    }
    // ...
```

### Step 5: Add OpenTelemetry to Workflow Starter
Update your workflow starter to include manual OpenTelemetry tracing for the complete workflow lifecycle:

```
package starter

import (
    "context"
    "fmt"
    "log"
    "time"

    "github.com/creator54/temporal-go-demo-app/internal/helloworld/config"
    "go.opentelemetry.io/otel"
    "go.opentelemetry.io/otel/attribute"
    "go.temporal.io/sdk/client"
)

// StartWorkflow initiates the HelloWorld workflow
func StartWorkflow(ctx context.Context, name string) error {
    // Create the client options
    clientOptions := client.Options{
        HostPort: client.DefaultHostPort,
    }

    // Initialize the Temporal client
    c, err := client.NewClient(clientOptions)
    if err != nil {
        return fmt.Errorf("unable to create client: %w", err)
    }
    defer c.Close()

    // Create workflow options
    workflowID := fmt.Sprintf("hello-world-%v", time.Now().Unix())
    workflowOptions := client.StartWorkflowOptions{
        ID:        workflowID,
        TaskQueue: "hello-world-task-queue",
    }

    // Create a tracer
    tr := otel.GetTracerProvider().Tracer("temporal-workflow")

    // Create the parent StartWorkflow span
    ctx, startSpan := tr.Start(ctx, "StartWorkflow")
    attrs := config.GetSpanAttributes("temporal", workflowID, workflowOptions.TaskQueue)
    for k, v := range attrs {
        startSpan.SetAttributes(attribute.String(k, v))
    }
    defer startSpan.End()

    // Start the workflow and track execution
    // ... workflow execution code
    
    return nil
}
```

### Step 6: Add Activity Tracing

Update your worker to include traced activities:

```go:worker.go
package worker

import (
    "context"
    "fmt"
    "log"
    // ... other imports
    "go.opentelemetry.io/otel"
    "go.opentelemetry.io/otel/attribute"
    "go.opentelemetry.io/otel/codes"
)

// HelloWorldActivity with OpenTelemetry tracing
func HelloWorldActivity(ctx context.Context, name string) (string, error) {
    // Get tracer
    tr := otel.Tracer("temporal-activity")
    
    // Create activity span
    ctx, span := tr.Start(ctx, "HelloWorldActivity")
    span.SetAttributes(attribute.String("activity.input", name))
    defer span.End()
    
    // Activity implementation
    result := fmt.Sprintf("Hello %s!", name)
    
    // Record result
    span.SetAttributes(attribute.String("activity.result", result))
    span.SetStatus(codes.Ok, "Success")
    
    return result, nil
}

// StartWorker initializes and starts a Temporal worker
func StartWorker() {
    // ... worker initialization code
}
```

### Step 7: Configure OpenTelemetry Propagation

Ensure proper context propagation between workflow components:

```go:internal/helloworld/config/opentelemetry_config.go
package config

import (
    "go.opentelemetry.io/otel"
    "go.opentelemetry.io/otel/propagation"
)

// SetupOTelPropagation configures the global propagator
func SetupOTelPropagation() {
    // Set global propagator
    otel.SetTextMapPropagator(propagation.NewCompositeTextMapPropagator(
        propagation.TraceContext{},
        propagation.Baggage{},
    ))
}

// GetSpanAttributes returns common attributes for spans
func GetSpanAttributes(workflowType, workflowID, taskQueue string) map[string]string {
    return map[string]string{
        "workflow.type":       workflowType,
        "workflow.id":         workflowID,
        "workflow.task_queue": taskQueue,
        "service.name":        "temporal-hello-world",
    }
}
```

### Step 8: Configure Main Application with OpenTelemetry

```go:cmd/helloworld/main.go
package main

import (
	"context"
	// ... other imports
	"github.com/creator54/temporal-go-demo-app/internal/helloworld/config"
)

func main() {
	// ... command line parsing and logging setup

	// Create a context that we can cancel
	ctx, cancel := context.WithCancel(context.Background())
	defer cancel()

	// ... signal handling

	// Initialize OpenTelemetry
	log.Println("[INFO] Initializing OpenTelemetry...")
	telemetry := config.NewSignozTelemetryUtils()
	cleanup, err := telemetry.InitProvider(ctx)
	if err != nil {
		log.Fatalf("[ERROR] Failed to initialize OpenTelemetry: %v", err)
	}
	defer func() {
		log.Println("[INFO] Cleaning up OpenTelemetry resources...")
		cleanup()
	}()
	log.Println("[INFO] OpenTelemetry initialized successfully")

	// ... worker and workflow execution logic
}
```

### Step 9: Configure Environment Variables

```bash
# SigNoz endpoint
export OTEL_EXPORTER_OTLP_ENDPOINT="http://localhost:4317"
export OTEL_SERVICE_NAME="temporal-hello-world"
export OTEL_RESOURCE_ATTRIBUTES="service.namespace=default,deployment.environment=development"
```

### Step 10: Run Application

1. Start the worker with tracing enabled:
```bash
go run cmd/helloworld/main.go -worker
```

2. Execute a workflow to generate traces:
```bash
go run cmd/helloworld/main.go
```

</TabItem>
</Tabs>
</TabItem>

<TabItem value="signoz-cloud" label="SigNoz Cloud">
<Tabs>
<TabItem value="java" label="Java" default>

### Step 1: Add OpenTelemetry Dependencies

Add to your `pom.xml`:

```xml
<properties>
    <opentelemetry.version>1.34.1</opentelemetry.version>
    <temporal.version>1.24.1</temporal.version>
</properties>

<dependencies>
    <!-- Temporal -->
    <dependency>
        <groupId>io.temporal</groupId>
        <artifactId>temporal-sdk</artifactId>
        <version>${temporal.version}</version>
    </dependency>
    <dependency>
        <groupId>io.temporal</groupId>
        <artifactId>temporal-opentracing</artifactId>
        <version>${temporal.version}</version>
    </dependency>

    <!-- OpenTelemetry -->
    <dependency>
        <groupId>io.opentelemetry</groupId>
        <artifactId>opentelemetry-api</artifactId>
        <version>${opentelemetry.version}</version>
    </dependency>
    <dependency>
        <groupId>io.opentelemetry</groupId>
        <artifactId>opentelemetry-sdk</artifactId>
        <version>${opentelemetry.version}</version>
    </dependency>
    <dependency>
        <groupId>io.opentelemetry</groupId>
        <artifactId>opentelemetry-exporter-otlp</artifactId>
        <version>${opentelemetry.version}</version>
    </dependency>
    <dependency>
        <groupId>io.opentelemetry</groupId>
        <artifactId>opentelemetry-extension-trace-propagators</artifactId>
        <version>${opentelemetry.version}</version>
    </dependency>
</dependencies>
```

### Step 2: Configure OpenTelemetry

Create `SignozTelemetryUtils.java` to configure OpenTelemetry with SigNoz OTLP exporter, trace propagation, and Temporal interceptors:

```java:src/main/java/helloworld/config/SignozTelemetryUtils.java
package helloworld.config;

import io.opentelemetry.api.OpenTelemetry;
import io.opentelemetry.api.metrics.Meter;
import io.opentelemetry.api.trace.Tracer;
import io.opentelemetry.api.trace.propagation.W3CTraceContextPropagator;
import io.opentelemetry.context.propagation.ContextPropagators;
import io.opentelemetry.sdk.OpenTelemetrySdk;
import io.temporal.common.interceptors.WorkerInterceptor;
import io.temporal.common.interceptors.WorkflowClientInterceptor;
import com.uber.m3.tally.Scope;
import java.util.logging.Level;
import java.util.logging.Logger;

public final class SignozTelemetryUtils {
    private static final Logger logger = Logger.getLogger(SignozTelemetryUtils.class.getName());
    private static volatile boolean isInitialized = false;
    private static volatile Tracer tracer;
    private static volatile Meter meter;

    public static synchronized void initializeTelemetry() {
        if (isInitialized) {
            logger.info("OpenTelemetry already initialized");
            return;
        }

        try {
            logger.info("Configuring OpenTelemetry with endpoint: " + OpenTelemetryConfig.getEndpoint());

            System.setProperty("otel.exporter.otlp.protocol", "grpc");
            System.setProperty("otel.exporter.otlp.endpoint", OpenTelemetryConfig.getEndpoint());

            OpenTelemetrySdk sdk = OpenTelemetrySdk.builder()
                .setTracerProvider(TracingExporter.createTracerProvider())
                .setMeterProvider(MetricsExporter.createMeterProvider())
                .setPropagators(ContextPropagators.create(W3CTraceContextPropagator.getInstance()))
                .build();

            OpenTelemetryConfig.setOpenTelemetry(sdk);
            isInitialized = true;

            Runtime.getRuntime().addShutdownHook(new Thread(() -> {
                try {
                    logger.info("Starting OpenTelemetry shutdown...");
                    TracingExporter.shutdown();
                    MetricsExporter.shutdown();
                    logger.info("OpenTelemetry shutdown completed");
                } catch (Exception e) {
                    logger.log(Level.SEVERE, "Error during OpenTelemetry shutdown", e);
                }
            }));

            logger.info("OpenTelemetry initialized successfully");
        } catch (Exception e) {
            logger.log(Level.SEVERE, "Error configuring OpenTelemetry", e);
            throw new RuntimeException("Failed to configure OpenTelemetry", e);
        }
    }

    public static OpenTelemetry getOpenTelemetry() {
        ensureInitialized();
        return OpenTelemetryConfig.getOpenTelemetry();
    }

    public static synchronized Tracer getTracer() {
        if (tracer == null) {
            tracer = getOpenTelemetry().getTracer(SignozTelemetryUtils.class.getName());
        }
        return tracer;
    }

    public static synchronized Meter getMeter() {
        if (meter == null) {
            meter = getOpenTelemetry().getMeter(SignozTelemetryUtils.class.getName());
        }
        return meter;
    }

    public static Scope getMetricsScope() {
        ensureInitialized();
        return MetricsExporter.getMetricsScope();
    }

    public static WorkerInterceptor getWorkerInterceptor() {
        ensureInitialized();
        return TracingExporter.getWorkerInterceptor();
    }

    public static WorkflowClientInterceptor getClientInterceptor() {
        ensureInitialized();
        return TracingExporter.getClientInterceptor();
    }

    private static void ensureInitialized() {
        if (!isInitialized) {
            throw new IllegalStateException("OpenTelemetry not initialized. Call initializeTelemetry() first.");
        }
    }

    private SignozTelemetryUtils() {
    }
}
```

### Step 3: Configure OpenTelemetry Settings

Create `OpenTelemetryConfig.java` to manage OpenTelemetry configuration including service attributes, resource settings, and endpoint configuration. This class will be used by the telemetry utilities to initialize the OpenTelemetry SDK.

```java:src/main/java/helloworld/config/OpenTelemetryConfig.java
package helloworld.config;

import io.opentelemetry.api.OpenTelemetry;
import io.opentelemetry.api.common.Attributes;
import io.opentelemetry.api.common.AttributeKey;
import io.opentelemetry.sdk.OpenTelemetrySdk;
import io.opentelemetry.sdk.resources.Resource;
import java.util.logging.Logger;

public final class OpenTelemetryConfig {
    private static final Logger logger = Logger.getLogger(OpenTelemetryConfig.class.getName());

    public static final String DEFAULT_SIGNOZ_ENDPOINT = "http://localhost:4317";

    public static final AttributeKey<String> SERVICE_NAMESPACE = AttributeKey.stringKey("service.namespace");
    public static final AttributeKey<String> DEPLOYMENT_ENVIRONMENT = AttributeKey.stringKey("deployment.environment");

    private static final String ENV_OTEL_ENDPOINT = "OTEL_EXPORTER_OTLP_ENDPOINT";
    private static final String ENV_ENVIRONMENT = "OTEL_ENVIRONMENT";

    private static volatile OpenTelemetry openTelemetry;

    public static OpenTelemetry getOpenTelemetry() {
        if (openTelemetry == null) {
            throw new IllegalStateException("OpenTelemetry not initialized. Call initialize() first.");
        }
        return openTelemetry;
    }

    public static Resource createResource() {
        String environment = System.getenv().getOrDefault(ENV_ENVIRONMENT, "development");

        Resource baseResource = Resource.getDefault();
        Resource customResource = Resource.create(Attributes.of(
            SERVICE_NAMESPACE, "default",
            DEPLOYMENT_ENVIRONMENT, environment
        ));

        logger.info("Creating resource with environment: " + environment);
        return baseResource.merge(customResource);
    }

    public static String getEndpoint() {
        return System.getenv().getOrDefault(ENV_OTEL_ENDPOINT, DEFAULT_SIGNOZ_ENDPOINT);
    }

    protected static synchronized void setOpenTelemetry(OpenTelemetrySdk sdk) {
        if (openTelemetry != null) {
            throw new IllegalStateException("OpenTelemetry already initialized");
        }
        openTelemetry = sdk;
    }

    private OpenTelemetryConfig() {
    }
}
```

### Step 4: Set Up Trace Export

Create `TracingExporter.java` to configure trace export to SigNoz with OTLP/gRPC, batch processing, and Temporal tracing:

```java:src/main/java/helloworld/config/TracingExporter.java
package helloworld.config;

import io.opentelemetry.exporter.otlp.trace.OtlpGrpcSpanExporter;
import io.opentelemetry.sdk.trace.SdkTracerProvider;
import io.opentelemetry.sdk.trace.export.BatchSpanProcessor;
import io.temporal.common.interceptors.WorkerInterceptor;
import io.temporal.common.interceptors.WorkflowClientInterceptor;
import io.temporal.opentracing.OpenTracingClientInterceptor;
import io.temporal.opentracing.OpenTracingOptions;
import io.temporal.opentracing.OpenTracingSpanContextCodec;
import io.temporal.opentracing.OpenTracingWorkerInterceptor;
import io.opentelemetry.opentracingshim.OpenTracingShim;
import java.util.logging.Logger;
import java.util.concurrent.TimeUnit;

public class TracingExporter {
    private static final Logger logger = Logger.getLogger(TracingExporter.class.getName());
    private static OpenTracingOptions openTracingOptions;
    private static BatchSpanProcessor spanProcessor;

    public static synchronized OpenTracingOptions getOpenTracingOptions() {
        if (openTracingOptions == null) {
            openTracingOptions = OpenTracingOptions.newBuilder()
                .setTracer(OpenTracingShim.createTracerShim(OpenTelemetryConfig.getOpenTelemetry()))
                .setSpanContextCodec(OpenTracingSpanContextCodec.TEXT_MAP_CODEC)
                .build();
        }
        return openTracingOptions;
    }

    public static WorkerInterceptor getWorkerInterceptor() {
        return new OpenTracingWorkerInterceptor(getOpenTracingOptions());
    }

    public static WorkflowClientInterceptor getClientInterceptor() {
        return new OpenTracingClientInterceptor(getOpenTracingOptions());
    }

    public static SdkTracerProvider createTracerProvider() {
        String endpoint = OpenTelemetryConfig.getEndpoint();

        OtlpGrpcSpanExporter spanExporter = OtlpGrpcSpanExporter.builder()
            .setEndpoint(endpoint)
            .addHeader("signoz-debug", "true")
            .setTimeout(java.time.Duration.ofSeconds(30))
            .build();

        spanProcessor = BatchSpanProcessor.builder(spanExporter)
            .setScheduleDelay(java.time.Duration.ofMillis(100))
            .setMaxQueueSize(2048)
            .setMaxExportBatchSize(512)
            .build();

        return SdkTracerProvider.builder()
            .addSpanProcessor(spanProcessor)
            .setResource(OpenTelemetryConfig.createResource())
            .build();
    }

    public static void shutdown() {
        if (spanProcessor != null) {
            try {
                logger.info("Shutting down span processor...");
                spanProcessor.forceFlush().join(10, TimeUnit.SECONDS);
                spanProcessor.shutdown().join(10, TimeUnit.SECONDS);
                logger.info("Span processor shutdown completed");
            } catch (Exception e) {
                logger.severe("Error during span processor shutdown: " + e.getMessage());
            }
        }
    }

    private TracingExporter() {
    }
}
```

### Step 5: Configure Worker with Tracing

Update your Temporal Worker to use the initialize OpenTelemetry for traces:

```java:src/main/java/helloworld/workers/HelloWorldWorker.java
package helloworld.workers;

import helloworld.config.TemporalConfig;
import helloworld.config.SignozTelemetryUtils;
import helloworld.workflows.impl.HelloWorldWorkflowImpl;
import io.temporal.worker.Worker;
import io.temporal.worker.WorkerFactory;
import io.temporal.worker.WorkerFactoryOptions;
import io.temporal.client.WorkflowClient;
import io.temporal.client.WorkflowClientOptions;
import io.temporal.serviceclient.WorkflowServiceStubsOptions;
import java.util.logging.Logger;
import java.util.logging.Level;

public class HelloWorldWorker implements AutoCloseable {
    private static final Logger logger = Logger.getLogger(HelloWorldWorker.class.getName());
    private final WorkerFactory factory;
    private final Worker worker;

    public HelloWorldWorker() {
        try {
            // Initialize OpenTelemetry with SigNoz configuration
            SignozTelemetryUtils.initializeTelemetry();
            logger.info("OpenTelemetry initialized successfully");

            // Configure service stubs with metrics
            WorkflowServiceStubsOptions stubOptions = WorkflowServiceStubsOptions.newBuilder()
                .setMetricsScope(SignozTelemetryUtils.getMetricsScope())
                .build();

            // Configure worker factory with tracing interceptor
            WorkerFactoryOptions factoryOptions = WorkerFactoryOptions.newBuilder()
                .setWorkerInterceptors(SignozTelemetryUtils.getWorkerInterceptor())
                .build();

            // Create workflow client with tracing interceptor
            WorkflowClient client = WorkflowClient.newInstance(
                TemporalConfig.getWorkflowServiceStubs(stubOptions),
                WorkflowClientOptions.newBuilder()
                    .setInterceptors(SignozTelemetryUtils.getClientInterceptor())
                    .build()
            );

            // Create factory with configured options
            this.factory = WorkerFactory.newInstance(client, factoryOptions);

            // Create and configure worker
            this.worker = factory.newWorker(TemporalConfig.getTaskQueue());
            this.worker.registerWorkflowImplementationTypes(HelloWorldWorkflowImpl.class);
            this.worker.registerActivitiesImplementations(new HelloWorldActivityImpl());
            
            logger.info("Worker initialized with OpenTelemetry integration");
        } catch (Exception e) {
            logger.log(Level.SEVERE, "Failed to initialize worker with OpenTelemetry", e);
            throw new RuntimeException("Worker initialization failed", e);
        }
    }

    // Additional methods for worker lifecycle management (start, close)
    // ...
}
```

### Step 6: Configure Workflow Starter
Update your Temporal Workflow Starter to use the initialize OpenTelemetry for traces:

```java:src/main/java/helloworld/main/HelloWorldStarter.java
package helloworld.main;

import helloworld.config.TemporalConfig;
import helloworld.config.SignozTelemetryUtils;
import helloworld.config.TracingExporter;
import helloworld.workflows.HelloWorldWorkflow;
import io.temporal.client.WorkflowClient;
import io.temporal.client.WorkflowClientOptions;
import io.temporal.client.WorkflowOptions;
import io.temporal.common.RetryOptions;
import io.temporal.serviceclient.WorkflowServiceStubsOptions;
import io.opentelemetry.api.trace.Span;
import io.opentelemetry.api.trace.StatusCode;
import io.opentelemetry.api.trace.Tracer;
import io.opentelemetry.context.Scope;
import java.time.Duration;
import java.util.UUID;

public class HelloWorldStarter {
    private final WorkflowClient client;
    private final Tracer tracer;

    public HelloWorldStarter() {
        // Initialize OpenTelemetry
        SignozTelemetryUtils.initializeTelemetry();
        this.tracer = SignozTelemetryUtils.getTracer();

        // Configure service stubs with OpenTelemetry
        WorkflowServiceStubsOptions stubOptions = WorkflowServiceStubsOptions.newBuilder()
            .setMetricsScope(SignozTelemetryUtils.getMetricsScope())
            .build();

        // Configure client with OpenTelemetry interceptor
        WorkflowClientOptions clientOptions = WorkflowClientOptions.newBuilder()
            .setInterceptors(SignozTelemetryUtils.getClientInterceptor())
            .build();

        // Create client with configured options
        this.client = TemporalConfig.getWorkflowClient(stubOptions, clientOptions);
    }

    public void runWorkflow(String name) {
        // Create workflow span for tracing
        Span workflowSpan = tracer.spanBuilder("StartWorkflow")
            .setAttribute("workflow.name", "HelloWorldWorkflow")
            .setAttribute("workflow.input", name)
            .setAttribute("workflow.type", "temporal")
            .startSpan();

        try (Scope scope = workflowSpan.makeCurrent()) {
            // Configure workflow options with retry policy
            WorkflowOptions options = WorkflowOptions.newBuilder()
                .setTaskQueue(TemporalConfig.getTaskQueue())
                .setWorkflowId("hello-world-" + UUID.randomUUID())
                .setRetryOptions(RetryOptions.newBuilder()
                    .setInitialInterval(Duration.ofSeconds(1))
                    .setMaximumInterval(Duration.ofSeconds(10))
                    .setBackoffCoefficient(2.0)
                    .setMaximumAttempts(3)
                    .build())
                .build();

            // Execute workflow with tracing
            HelloWorldWorkflow workflow = client.newWorkflowStub(HelloWorldWorkflow.class, options);
            String result = workflow.sayHello(name);
            
            workflowSpan.setStatus(StatusCode.OK);
            System.out.println("Workflow result: " + result);
        } catch (Exception e) {
            workflowSpan.recordException(e);
            workflowSpan.setStatus(StatusCode.ERROR);
            throw new RuntimeException("Workflow execution failed", e);
        } finally {
            workflowSpan.end();
            TracingExporter.shutdown();
        }
    }

    // Additional methods and main entry point
    // ...
}
```

### Step 7: Configure Environment Variables for SigNoz Cloud
```bash
# SigNoz Cloud endpoint
OTEL_EXPORTER_OTLP_ENDPOINT=https://ingest.{region}.signoz.cloud:443

# Set service name and other attributes
OTEL_RESOURCE_ATTRIBUTES="service.name=temporal-hello-world"

# SigNoz Cloud authentication
OTEL_EXPORTER_OTLP_HEADERS="signoz-ingestion-key=<your-signoz-key>"
```

### Step 8: Run Application

1. Start the worker with tracing enabled:
```bash
mvn exec:java -Dexec.mainClass="helloworld.workers.HelloWorldWorker"
```

2. Execute workflows to generate traces in another terminal:
```bash
mvn exec:java -Dexec.mainClass="helloworld.main.HelloWorldStarter"
```

</TabItem>

<TabItem value="typescript" label="TypeScript">

### Step 1: Add OpenTelemetry Dependencies

Add the following dependencies to your `package.json`:

```json
{
  "dependencies": {
    "@grpc/grpc-js": "^1.9.0",
    "@opentelemetry/api": "^1.7.0",
    "@opentelemetry/auto-instrumentations-node": "^0.56.1",
    "@opentelemetry/core": "^1.19.0",
    "@opentelemetry/exporter-metrics-otlp-grpc": "^0.46.0",
    "@opentelemetry/exporter-metrics-otlp-http": "^0.57.2",
    "@opentelemetry/exporter-trace-otlp-grpc": "^0.46.0",
    "@opentelemetry/exporter-trace-otlp-http": "^0.57.2",
    "@opentelemetry/exporter-trace-otlp-proto": "^0.57.2",
    "@opentelemetry/instrumentation": "^0.46.0",
    "@opentelemetry/resources": "^1.19.0",
    "@opentelemetry/sdk-metrics": "^1.19.0",
    "@opentelemetry/sdk-node": "^0.46.0",
    "@opentelemetry/sdk-trace-base": "^1.19.0",
    "@opentelemetry/sdk-trace-node": "^1.19.0",
    "@opentelemetry/semantic-conventions": "^1.19.0",
    "@temporalio/client": "^1.9.0",
    "@temporalio/common": "^1.9.0",
    "@temporalio/worker": "^1.9.0",
    "@temporalio/workflow": "^1.9.0"
  }
}
```

### Step 2: Configure OpenTelemetry Utilities

Create `signozTelemetryUtils.ts` to manage OpenTelemetry SDK lifecycle and provide access to tracer and meter instances for SigNoz integration:

```typescript:src/config/signozTelemetryUtils.ts
import { diag, trace, metrics, Tracer, Meter } from '@opentelemetry/api';
import { NodeSDK } from '@opentelemetry/sdk-node';

// Store SDK instances for direct access
let sdkInstance: NodeSDK | null = null;
let tracerInstance: Tracer | null = null;
let meterInstance: Meter | null = null;

// Get or create tracer instance
export function getTracer(): Tracer {
    if (!tracerInstance) {
        tracerInstance = trace.getTracer('temporal-hello-world');
    }
    return tracerInstance;
}

// Get or create meter instance
export function getMeter(): Meter {
    if (!meterInstance) {
        meterInstance = metrics.getMeter('temporal-hello-world');
    }
    return meterInstance;
}

// Store the SDK instance
export function setOpenTelemetrySdk(sdk: NodeSDK): void {
    sdkInstance = sdk;
}

// Access the SDK instance
export function getOpenTelemetrySdk(): NodeSDK | null {
    return sdkInstance;
}

// Ensure all telemetry data is exported before shutdown
export async function forceSpanExport(): Promise<boolean> {
    if (!sdkInstance) {
        return false;
    }
    
    const timeoutPromise = new Promise<boolean>((resolve) => {
        setTimeout(() => resolve(false), 3000);
    });
    
    const shutdownPromise = sdkInstance.shutdown()
        .then(() => true)
        .catch(() => false);
    
    return Promise.race([shutdownPromise, timeoutPromise]);
}
```

### Step 3: Configure OpenTelemetry Trace Exporter

Create `tracingExporter.ts` to configure the trace exporter:

```typescript:src/config/tracingExporter.ts
import { diag } from '@opentelemetry/api';
import { OTLPTraceExporter } from '@opentelemetry/exporter-trace-otlp-grpc';

export function getTracingExporter(): OTLPTraceExporter {
    const endpoint = process.env.OTEL_EXPORTER_OTLP_ENDPOINT || 'http://localhost:4317';
    diag.info(`[TELEMETRY] Configuring trace exporter with gRPC protocol: ${endpoint}`);
    
    return new OTLPTraceExporter({
        url: endpoint, // For gRPC, we don't need to specify the path
    });
}

export function configureTracingEnvironment(): void {
    // Configure environment variables for tracing
    process.env.OTEL_TRACES_EXPORTER = 'otlp';
    process.env.OTEL_TRACES_SAMPLER = 'always_on';
}
```

### Step 4: Configure OpenTelemetry SDK

Create `opentelemetryConfig.ts` to initialize the OpenTelemetry SDK:

```typescript:src/config/opentelemetryConfig.ts
import { NodeSDK } from '@opentelemetry/sdk-node';
import { Resource } from '@opentelemetry/resources';
import { ATTR_SERVICE_NAME } from '@opentelemetry/semantic-conventions';
import { diag, DiagConsoleLogger, DiagLogLevel } from '@opentelemetry/api';
import { CompositePropagator, W3CTraceContextPropagator, W3CBaggagePropagator } from '@opentelemetry/core';
import { getNodeAutoInstrumentations } from '@opentelemetry/auto-instrumentations-node';
import { getMetricsReader } from './metricsExporter';
import { getTracingExporter, configureTracingEnvironment } from './tracingExporter';
import { configureMetricsEnvironment } from './metricsExporter';
import { setOpenTelemetrySdk } from './signozTelemetryUtils';

// Define incubating semantic convention attributes
const ATTR_SERVICE_NAMESPACE = 'service.namespace';
const ATTR_DEPLOYMENT_ENVIRONMENT = 'deployment.environment';

// Logger configuration state
let loggerConfigured = false;

function configureLogger(logLevel: DiagLogLevel = DiagLogLevel.INFO): void {
    if (!loggerConfigured) {
        diag.setLogger(new DiagConsoleLogger(), logLevel);
        loggerConfigured = true;
        diag.info('[TELEMETRY] OpenTelemetry logger configured');
    }
}

function configureEnvironmentVariables(serviceName: string): void {
    // Configure core environment variables
    process.env.OTEL_SERVICE_NAME = serviceName;
    process.env.OTEL_EXPORTER_OTLP_PROTOCOL = 'grpc';
    process.env.OTEL_PROPAGATORS = 'tracecontext,baggage';
    process.env.OTEL_LOGS_EXPORTER = 'none';
    
    // Configure tracing and metrics
    configureTracingEnvironment();
    configureMetricsEnvironment();
    
    // Log environment configuration for debugging
    diag.debug('[TELEMETRY] Environment variables:', {
        OTEL_EXPORTER_OTLP_ENDPOINT: process.env.OTEL_EXPORTER_OTLP_ENDPOINT || 'http://localhost:4317',
        OTEL_EXPORTER_OTLP_PROTOCOL: process.env.OTEL_EXPORTER_OTLP_PROTOCOL,
        OTEL_RESOURCE_ATTRIBUTES: process.env.OTEL_RESOURCE_ATTRIBUTES,
        OTEL_SERVICE_NAME: process.env.OTEL_SERVICE_NAME,
    });
}

function createServiceResource(serviceName: string): Resource {
    return Resource.default().merge(
        new Resource({
            [ATTR_SERVICE_NAME]: serviceName,
            [ATTR_SERVICE_NAMESPACE]: 'default',
            [ATTR_DEPLOYMENT_ENVIRONMENT]: process.env.OTEL_ENVIRONMENT || 'development',
        })
    );
}

export async function initOpenTelemetry(serviceName: string): Promise<NodeSDK> {
    // Configure the logger first
    configureLogger();
    
    diag.info('[TELEMETRY] Initializing OpenTelemetry for service:', serviceName);

    // Configure environment variables
    configureEnvironmentVariables(serviceName);

    try {
        // Create and configure the SDK
        const sdk = new NodeSDK({
            resource: createServiceResource(serviceName),
            traceExporter: getTracingExporter(),
            // Use as any to bypass type conflicts between different @opentelemetry/sdk-metrics versions
            metricReader: getMetricsReader() as any,
            textMapPropagator: new CompositePropagator({
                propagators: [
                    new W3CTraceContextPropagator(),
                    new W3CBaggagePropagator()
                ],
            }),
            instrumentations: [
                getNodeAutoInstrumentations({
                    '@opentelemetry/instrumentation-http': { enabled: true },
                    '@opentelemetry/instrumentation-grpc': { enabled: true },
                }),
            ]
        });

        // Store SDK instance in utilities
        setOpenTelemetrySdk(sdk);

        // Start the SDK
        await sdk.start();
        diag.info('[TELEMETRY] OpenTelemetry SDK initialized successfully for', serviceName);

        // Register shutdown handler for clean exit
        registerShutdownHandler(sdk);

        return sdk;
    } catch (error) {
        diag.error('[TELEMETRY] Failed to initialize OpenTelemetry:', error instanceof Error ? error.message : String(error));
        throw error;
    }
}

function registerShutdownHandler(sdk: NodeSDK): void {
    const shutdown = async () => {
        diag.info('[TELEMETRY] Shutting down OpenTelemetry SDK');
        
        try {
            const shutdownPromise = sdk.shutdown();
            const timeoutPromise = new Promise((_, reject) => 
                setTimeout(() => reject(new Error('Shutdown timed out')), 5000)
            );
            
            await Promise.race([shutdownPromise, timeoutPromise]);
            diag.info('[TELEMETRY] OpenTelemetry SDK shut down successfully');
        } catch (error) {
            diag.error('[TELEMETRY] Error shutting down OpenTelemetry SDK:', 
                error instanceof Error ? error.message : String(error));
        }
    };

    // Handle various termination signals
    process.on('SIGTERM', shutdown);
    process.on('SIGINT', shutdown);
    
    // Handle uncaught errors
    process.on('uncaughtException', async (error) => {
        diag.error('[TELEMETRY] Uncaught exception, shutting down telemetry before exit:', error);
        await shutdown();
    });
}
```

### Step 5: Configure Temporal Worker with Tracing

Create a worker with OpenTelemetry integration:

```typescript:src/worker.ts
import { trace, SpanKind, context, SpanStatusCode } from '@opentelemetry/api';
import { getTracer, forceSpanExport } from './config/signozTelemetryUtils';

// Initialize tracer
const tracer = getTracer();

// Create main worker span
const executeWorkflowSpan = tracer.startSpan('ExecuteWorkflow', {
  kind: SpanKind.INTERNAL,
  attributes: {
    'worker.type': 'temporal',
    'service.name': 'temporal-hello-world',
    'workflow.task_queue': DEFAULT_TASK_QUEUE,
    'temporal.component': 'worker'
  }
});

// Make the span active for the worker lifetime
const workerContext = trace.setSpan(context.active(), executeWorkflowSpan);

await context.with(workerContext, async () => {
  try {
    // Worker implementation...
    
    // Graceful shutdown handling
    const shutdown = async () => {
      // Worker shutdown logic...
      executeWorkflowSpan.end();
      await forceSpanExport();
    };
  } catch (err) {
    // Error handling with span
    executeWorkflowSpan.setStatus({
      code: SpanStatusCode.ERROR,
      message: err instanceof Error ? err.message : String(err)
    });
    executeWorkflowSpan.end();
    await forceSpanExport();
  }
});
```

### Step 6: Configure Workflow Client with Tracing

Create a client with OpenTelemetry tracing:

```typescript:src/client.ts
import { Client, Connection } from '@temporalio/client';
import { initOpenTelemetry } from './config/opentelemetryConfig';
import { forceSpanExport, getTracer, getMeter } from './config/signozTelemetryUtils';
import { DEFAULT_TASK_QUEUE } from './config/temporalConfig';
import { trace, SpanKind, context, SpanStatusCode } from '@opentelemetry/api';

async function run() {
  // Initialize OpenTelemetry
  console.log('[STARTER] Initializing OpenTelemetry...');
  await initOpenTelemetry('temporal-hello-world');

  // Get tracer and meter instances for instrumentation
  const tracer = getTracer();
  const meter = getMeter();

  // Create workflow execution counter
  const workflowCounter = meter.createCounter('workflow.executions', {
    description: 'Number of workflow executions'
  });

  // Create main span for the entire workflow execution process
  const startWorkflowSpan = tracer.startSpan('StartWorkflow', {
    kind: SpanKind.INTERNAL,
    attributes: {
      'workflow.type': 'temporal',
      'service.name': 'temporal-hello-world',
      'temporal.component': 'starter',
    }
  });

  // Make the span active for this context
  const starterContext = trace.setSpan(context.active(), startWorkflowSpan);
  
  try {
    await context.with(starterContext, async () => {
      // ... Temporal connection logic ...
      
      const workflowId = `hello-world-${generateId()}`;
      
      // Create child spans for the specific workflow execution
      const executeWorkflowSpan = tracer.startSpan('ExecuteWorkflow', {
        kind: SpanKind.INTERNAL,
        attributes: {
          'workflow.id': workflowId,
          'workflow.name': 'HelloWorldWorkflow',
          'workflow.task_queue': taskQueue,
          'temporal.workflow.type': 'HelloWorldWorkflow'
        }
      });

      // Track the execution with our counter
      workflowCounter.add(1, {
        'workflow.name': 'HelloWorldWorkflow',
        'workflow.task_queue': taskQueue
      });

      try {
        // ... Workflow execution logic ...

        // Record successful outcome in our spans
        executeWorkflowSpan.setStatus({ code: SpanStatusCode.OK });
        executeWorkflowSpan.setAttribute('workflow.status', 'completed');
        executeWorkflowSpan.setAttribute('workflow.result', result);
        executeWorkflowSpan.end();
        
      } catch (err) {
        // Record error in our spans
        executeWorkflowSpan.setStatus({
          code: SpanStatusCode.ERROR,
          message: err instanceof Error ? err.message : String(err)
        });
        executeWorkflowSpan.setAttribute('workflow.status', 'failed');
        executeWorkflowSpan.end();
      }
    });
  } catch (err) {
    startWorkflowSpan.setStatus({
      code: SpanStatusCode.ERROR,
      message: err instanceof Error ? err.message : String(err)
    });
  } finally {
    // Always end the main span and force export
    startWorkflowSpan.end();
    await forceSpanExport();
  }
}

run();
```

### Step 7: Define Workflows with OpenTelemetry Integration

Workflows don't require direct OpenTelemetry instrumentation because tracing context is automatically propagated by Temporal's infrastructure.

```typescript:src/workflows/impl/helloWorldWorkflowImpl.ts
import { proxyActivities } from '@temporalio/workflow';
import { HelloWorldWorkflow } from '../interfaces/helloWorldWorkflow';
import * as activities from '../../activities/index';

// Activities are proxied through Temporal which maintains tracing context
const { formatName, generateGreeting, addTimestamp } = proxyActivities<typeof activities>({
  startToCloseTimeout: '1 minute',
});

export class HelloWorldWorkflowImpl implements HelloWorldWorkflow {
  async sayHello(name: string): Promise<string> {
    // Each activity call is automatically traced through context propagation
    // The spans created by activities are connected to the parent spans created in the worker
    const formattedName = await formatName(name);
    const greeting = await generateGreeting(formattedName);
    const timestampedGreeting = await addTimestamp(greeting);
    
    return timestampedGreeting;
  }
}

// Workflow function that Temporal executes
export async function sayHello(name: string): Promise<string> {
  const workflow = new HelloWorldWorkflowImpl();
  return workflow.sayHello(name);
}
```

### Step 8: Configure Environment Variables

```bash
# SigNoz endpoint
# SigNoz Cloud endpoint
OTEL_EXPORTER_OTLP_ENDPOINT=https://ingest.{region}.signoz.cloud:443

# Set service name and other attributes
OTEL_RESOURCE_ATTRIBUTES="service.name=temporal-hello-world"

# SigNoz Cloud authentication
OTEL_EXPORTER_OTLP_HEADERS="signoz-ingestion-key=<your-signoz-key>"
```

### Step 9: Add Basic Temporal Configuration

```typescript:src/config/temporalConfig.ts
// Default Temporal configuration
export const DEFAULT_TASK_QUEUE = 'hello-world-task-queue';
```

### Step 10: Run Application

1. Start the worker with tracing enabled:
```bash
npm run worker
```

2. Execute a workflow to generate traces:
```bash
npm run workflow
```

</TabItem>

<TabItem value="go" label="Go">

### Step 1: Add OpenTelemetry Dependencies

Add the following dependencies to your `go.mod`:

```go
require (
	go.opentelemetry.io/otel v1.24.0
	go.opentelemetry.io/otel/exporters/otlp/otlpmetric/otlpmetricgrpc v1.24.0
	go.opentelemetry.io/otel/exporters/otlp/otlptrace/otlptracegrpc v1.24.0
	go.opentelemetry.io/otel/metric v1.24.0
	go.opentelemetry.io/otel/sdk v1.24.0
	go.opentelemetry.io/otel/sdk/metric v1.24.0
	go.opentelemetry.io/otel/trace v1.24.0
	go.temporal.io/api v1.24.0
	go.temporal.io/sdk v1.25.1
	go.temporal.io/sdk/contrib/opentelemetry v0.3.0
)
```

### Step 2: Configure OpenTelemetry

Create `signoz_telemetry_utils.go` to coordinate the OpenTelemetry components:

```go:internal/helloworld/config/signoz_telemetry_utils.go
package config

import (
	"context"
	"fmt"
	"log"
	"time"

	"go.opentelemetry.io/otel"
)

// SignozTelemetryUtils coordinates all telemetry components
type SignozTelemetryUtils struct {
	otelConfig *OpenTelemetryConfig
}

// NewSignozTelemetryUtils creates a new telemetry configuration
func NewSignozTelemetryUtils() *SignozTelemetryUtils {
	return &SignozTelemetryUtils{
		otelConfig: NewOpenTelemetryConfig(),
	}
}

// InitProvider initializes all telemetry providers
func (c *SignozTelemetryUtils) InitProvider(ctx context.Context) (func(), error) {
	// Create resource
	res, err := c.otelConfig.CreateResource(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed to create resource: %w", err)
	}

	// Get TLS credentials
	creds := c.otelConfig.GetTLSCredentials()

	// Initialize metrics
	metricsConfig := &MetricsExporterConfig{
		ServiceName: c.otelConfig.ServiceName,
		Environment: c.otelConfig.Environment,
		Endpoint:    c.otelConfig.Endpoint,
		Headers:     c.otelConfig.Headers,
		TLSCreds:    creds,
	}
	meterProvider, err := NewMetricsExporter(ctx, metricsConfig, res)
	if err != nil {
		return nil, fmt.Errorf("failed to create metrics exporter: %w", err)
	}

	// Set global meter provider
	otel.SetMeterProvider(meterProvider)

	// Initialize tracing
	tracingConfig := &TracingExporterConfig{
		ServiceName: c.otelConfig.ServiceName,
		Environment: c.otelConfig.Environment,
		Endpoint:    c.otelConfig.Endpoint,
		Headers:     c.otelConfig.Headers,
		TLSCreds:    creds,
	}
	tracerProvider, err := NewTracingExporter(ctx, tracingConfig, res)
	if err != nil {
		return nil, fmt.Errorf("failed to create tracer provider: %w", err)
	}

	// Set global tracer provider
	otel.SetTracerProvider(tracerProvider)

	// Setup propagator
	SetupPropagator()

	// ...

	// Return cleanup function
	cleanup := func() {
		shutdownCtx, cancel := context.WithTimeout(context.Background(), 30*time.Second)
		defer cancel()

		if err := tracerProvider.Shutdown(shutdownCtx); err != nil {
			log.Printf("[ERROR] Error shutting down tracer provider: %v\n", err)
		}

		if err := meterProvider.Shutdown(shutdownCtx); err != nil {
			log.Printf("[ERROR] Error shutting down meter provider: %v\n", err)
		}
	}

	return cleanup, nil
}
```

### Step 3: Configure OpenTelemetry Settings

Create `opentelemetry_config.go` to manage OpenTelemetry configuration:

```go:internal/helloworld/config/opentelemetry_config.go
package config

import (
	"context"
	"fmt"
	"os"
	"strings"

	"go.opentelemetry.io/otel"
	"go.opentelemetry.io/otel/propagation"
	"go.opentelemetry.io/otel/sdk/resource"
	semconv "go.opentelemetry.io/otel/semconv/v1.24.0"
	"google.golang.org/grpc/credentials"
	"google.golang.org/grpc/credentials/insecure"
)

// OpenTelemetryConfig holds OpenTelemetry configuration
type OpenTelemetryConfig struct {
	ServiceName string
	Environment string
	Endpoint    string
	Headers     map[string]string
	UseTLS      bool
}

// NewOpenTelemetryConfig creates a new OpenTelemetry configuration
func NewOpenTelemetryConfig() *OpenTelemetryConfig {
	endpoint := os.Getenv("OTEL_EXPORTER_OTLP_ENDPOINT")
	if endpoint == "" {
		endpoint = "localhost:4317"
	} else {
		// Strip http:// or https:// prefix
		endpoint = strings.TrimPrefix(strings.TrimPrefix(endpoint, "http://"), "https://")
	}

	return &OpenTelemetryConfig{
		ServiceName: "temporal-hello-world",
		Environment: "development",
		Endpoint:    endpoint,
		Headers:     parseHeaders(),
		UseTLS:      false,
	}
}

// CreateResource creates a new resource with common attributes
func (c *OpenTelemetryConfig) CreateResource(ctx context.Context) (*resource.Resource, error) {
	hostname, _ := os.Hostname()
	return resource.New(ctx,
		resource.WithAttributes(
			semconv.ServiceName(c.ServiceName),
			semconv.ServiceVersion("1.0.0"),
			semconv.DeploymentEnvironment(c.Environment),
			semconv.HostName(hostname),
			semconv.ServiceInstanceID(fmt.Sprintf("%s-%d", hostname, os.Getpid())),
		),
		resource.WithSchemaURL(semconv.SchemaURL),
	)
}

// GetTLSCredentials returns the appropriate TLS credentials
func (c *OpenTelemetryConfig) GetTLSCredentials() credentials.TransportCredentials {
	if c.UseTLS {
		return credentials.NewClientTLSFromCert(nil, "")
	}
	return insecure.NewCredentials()
}

// SetupPropagator configures the global propagator
func SetupPropagator() {
	otel.SetTextMapPropagator(propagation.NewCompositeTextMapPropagator(
		propagation.TraceContext{},
		propagation.Baggage{},
	))
}

// parseHeaders parses OTEL_EXPORTER_OTLP_HEADERS environment variable
func parseHeaders() map[string]string {
	headers := make(map[string]string)
	headerStr := os.Getenv("OTEL_EXPORTER_OTLP_HEADERS")
	if headerStr != "" {
		// Parse headers in format "key1=value1,key2=value2"
		pairs := strings.Split(headerStr, ",")
		for _, pair := range pairs {
			kv := strings.SplitN(pair, "=", 2)
			if len(kv) == 2 {
				headers[strings.TrimSpace(kv[0])] = strings.TrimSpace(kv[1])
			}
		}
	}
	return headers
}
```

### Step 4: Set Up Trace Export

Create `tracing_exporter.go` to configure the OTLP trace exporter:

```go:internal/helloworld/config/tracing_exporter.go
package config
import (
    "context"
    "fmt"
    "time"
    "go.opentelemetry.io/otel/exporters/otlp/otlptrace/otlptracegrpc"
    "go.opentelemetry.io/otel/sdk/resource"
    sdktrace "go.opentelemetry.io/otel/sdk/trace"
    "google.golang.org/grpc/credentials"
)
// TracingExporterConfig holds configuration for tracing export
type TracingExporterConfig struct {
    ServiceName string
    Environment string
    Endpoint string
    Headers map[string] string
    TLSCreds credentials.TransportCredentials
}
// NewTracingExporter creates and configures the tracing exporter
func NewTracingExporter(ctx context.Context, cfg TracingExporterConfig, res resource.Resource)(sdktrace.TracerProvider, error) {
        // Configure trace exporter
        exporter, err: = otlptracegrpc.New(ctx,
            otlptracegrpc.WithEndpoint(cfg.Endpoint),
            otlptracegrpc.WithHeaders(cfg.Headers),
            otlptracegrpc.WithTLSCredentials(cfg.TLSCreds),
            otlptracegrpc.WithRetry(otlptracegrpc.RetryConfig {
                Enabled: true,
                InitialInterval: 1 * time.Second,
                MaxInterval: 5 * time.Second,
                MaxElapsedTime: 30 * time.Second,
            }),
        )
        if err != nil {
                return nil, fmt.Errorf("failed to create trace exporter: %w", err)
            }
            // Configure tracer provider with more frequent batching
        tracerProvider: = sdktrace.NewTracerProvider(
            sdktrace.WithResource(res),
            sdktrace.WithSampler(sdktrace.AlwaysSample()),
            sdktrace.WithBatcher(exporter,
                sdktrace.WithBatchTimeout(5 time.Second),
                sdktrace.WithMaxExportBatchSize(512),
                sdktrace.WithMaxQueueSize(2048),
            ),
        )
        return tracerProvider, nil
    }
    // ...
```

### Step 5: Add OpenTelemetry to Workflow Starter
Update your workflow starter to include manual OpenTelemetry tracing for the complete workflow lifecycle:

```
package starter

import (
    "context"
    "fmt"
    "log"
    "time"

    "github.com/creator54/temporal-go-demo-app/internal/helloworld/config"
    "go.opentelemetry.io/otel"
    "go.opentelemetry.io/otel/attribute"
    "go.temporal.io/sdk/client"
)

// StartWorkflow initiates the HelloWorld workflow
func StartWorkflow(ctx context.Context, name string) error {
    // Create the client options
    clientOptions := client.Options{
        HostPort: client.DefaultHostPort,
    }

    // Initialize the Temporal client
    c, err := client.NewClient(clientOptions)
    if err != nil {
        return fmt.Errorf("unable to create client: %w", err)
    }
    defer c.Close()

    // Create workflow options
    workflowID := fmt.Sprintf("hello-world-%v", time.Now().Unix())
    workflowOptions := client.StartWorkflowOptions{
        ID:        workflowID,
        TaskQueue: "hello-world-task-queue",
    }

    // Create a tracer
    tr := otel.GetTracerProvider().Tracer("temporal-workflow")

    // Create the parent StartWorkflow span
    ctx, startSpan := tr.Start(ctx, "StartWorkflow")
    attrs := config.GetSpanAttributes("temporal", workflowID, workflowOptions.TaskQueue)
    for k, v := range attrs {
        startSpan.SetAttributes(attribute.String(k, v))
    }
    defer startSpan.End()

    // Start the workflow and track execution
    // ... workflow execution code
    
    return nil
}
```

### Step 6: Add Activity Tracing

Update your worker to include traced activities:

```go:worker.go
package worker

import (
    "context"
    "fmt"
    "log"
    // ... other imports
    "go.opentelemetry.io/otel"
    "go.opentelemetry.io/otel/attribute"
    "go.opentelemetry.io/otel/codes"
)

// HelloWorldActivity with OpenTelemetry tracing
func HelloWorldActivity(ctx context.Context, name string) (string, error) {
    // Get tracer
    tr := otel.Tracer("temporal-activity")
    
    // Create activity span
    ctx, span := tr.Start(ctx, "HelloWorldActivity")
    span.SetAttributes(attribute.String("activity.input", name))
    defer span.End()
    
    // Activity implementation
    result := fmt.Sprintf("Hello %s!", name)
    
    // Record result
    span.SetAttributes(attribute.String("activity.result", result))
    span.SetStatus(codes.Ok, "Success")
    
    return result, nil
}

// StartWorker initializes and starts a Temporal worker
func StartWorker() {
    // ... worker initialization code
}
```

### Step 7: Configure OpenTelemetry Propagation

Ensure proper context propagation between workflow components:

```go:internal/helloworld/config/opentelemetry_config.go
package config

import (
    "go.opentelemetry.io/otel"
    "go.opentelemetry.io/otel/propagation"
)

// SetupOTelPropagation configures the global propagator
func SetupOTelPropagation() {
    // Set global propagator
    otel.SetTextMapPropagator(propagation.NewCompositeTextMapPropagator(
        propagation.TraceContext{},
        propagation.Baggage{},
    ))
}

// GetSpanAttributes returns common attributes for spans
func GetSpanAttributes(workflowType, workflowID, taskQueue string) map[string]string {
    return map[string]string{
        "workflow.type":       workflowType,
        "workflow.id":         workflowID,
        "workflow.task_queue": taskQueue,
        "service.name":        "temporal-hello-world",
    }
}
```

### Step 8: Configure Main Application with OpenTelemetry

```go:cmd/helloworld/main.go
package main

import (
	"context"
	// ... other imports
	"github.com/creator54/temporal-go-demo-app/internal/helloworld/config"
)

func main() {
	// ... command line parsing and logging setup

	// Create a context that we can cancel
	ctx, cancel := context.WithCancel(context.Background())
	defer cancel()

	// ... signal handling

	// Initialize OpenTelemetry
	log.Println("[INFO] Initializing OpenTelemetry...")
	telemetry := config.NewSignozTelemetryUtils()
	cleanup, err := telemetry.InitProvider(ctx)
	if err != nil {
		log.Fatalf("[ERROR] Failed to initialize OpenTelemetry: %v", err)
	}
	defer func() {
		log.Println("[INFO] Cleaning up OpenTelemetry resources...")
		cleanup()
	}()
	log.Println("[INFO] OpenTelemetry initialized successfully")

	// ... worker and workflow execution logic
}
```

### Step 9: Configure Environment Variables

```bash
# SigNoz endpoint
export OTEL_EXPORTER_OTLP_ENDPOINT="http://localhost:4317"

# Set service name and other attributes
OTEL_RESOURCE_ATTRIBUTES="service.name=temporal-hello-world"
```

### Step 10: Run Application

1. Start the worker with tracing enabled:
```bash
go run cmd/helloworld/main.go -worker
```

2. Execute a workflow to generate traces:
```bash
go run cmd/helloworld/main.go
```

</TabItem>
</Tabs>
</TabItem>
</Tabs>

## Monitoring in SigNoz

### View Services

Navigate to the `Services` tab to find your Temporal application:

<figure data-zoomable align='center'>
<img src="/img/docs/instrumentation/temporal-services.webp" alt="Services view"/>
<figcaption><i>Services overview showing Temporal application</i></figcaption>
</figure>

### Analyze Traces

The `Traces` tab displays workflow executions including spans, durations, errors, and metadata.

<figure data-zoomable align='center'>
<img src="/img/docs/instrumentation/temporal-traces.webp" alt="Traces view"/>
<figcaption><i>Trace analysis with workflow details</i></figcaption>
</figure>

### Trace Details

Click any trace to see:

- Complete workflow execution timeline
- Activity execution details
- Custom attributes and tags
- Error information

<figure data-zoomable align='center'>
<img src="/img/docs/instrumentation/temporal-trace-details.webp" alt="Trace details"/>
<figcaption><i>Detailed trace view with spans and attributes</i></figcaption>
</figure>

## Sample Application

Check out our sample applications on GitHub:
- [Java Sample App](https://github.com/Creator54/temporal-java-demo-app)
- [TypeScript Sample App](https://github.com/Creator54/temporal-typescript-demo-app)
- [Go Sample App](https://github.com/Creator54/temporal-go-demo-app)
- Use the `main` branch to follow along with the implementation steps
- Switch to the `otel` branch to see the complete OpenTelemetry integration

## Troubleshooting

### Common Issues

1. **No Traces Visible**
   - Verify SigNoz endpoint configuration
   - Check ingestion key (for SigNoz Cloud)
   - Ensure OpenTelemetry initialization succeeds
   - Verify Temporal server is running

2. **Missing Spans**
   - Check worker registration
   - Verify workflow implementation registration
   - Ensure proper task queue configuration

3. **Connection Issues**
   - Check network connectivity
   - Verify endpoint protocol (http/https)
   - Check port accessibility
   - Verify TLS configuration (if using SigNoz Cloud)
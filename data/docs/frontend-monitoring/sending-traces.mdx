---
date: 2025-07-30
title: Sending Traces from your frontend application
id: sending-traces-frontend
---

This documentation provides a step-by-step guide for sending traces from your frontend application using SigNoz and OpenTelemetry.

## Overview

SigNoz natively supports OpenTelemetry for collecting traces, so you can instrument your frontend applications with minimal setup and get deep visibility into user interactions and network activity.

Client side traces help you understand how user actions trigger requests, how long they take, and where latency is introduced, whether in the browser, network, or backend. This gives you a complete picture of user journeys and performance across your stack.

## Prerequisites

- [SigNoz Cloud](https://signoz.io/teams/) account
- A web application from where you want to send traces

## Setup

### Step 1: Setup OTel Collector

Install the OpenTelemetry Collector binary using [these instructions](https://signoz.io/docs/tutorial/opentelemetry-binary-usage-in-virtual-machine/). The Collector acts as an agent that receives, processes, and exports telemetry data. It is required to collect data from your application, including traces.

### Step 2: Install dependencies

<Tabs groupId="traces-dependencies">
  <TabItem value="npm" label="Npm">
    ```sh
    npm i \
      @opentelemetry/sdk-trace-base \
      @opentelemetry/sdk-trace-web \
      @opentelemetry/exporter-trace-otlp-http \
      @opentelemetry/instrumentation \
      @opentelemetry/instrumentation-fetch \
      @opentelemetry/instrumentation-xml-http-request \
      @opentelemetry/context-zone \
      @opentelemetry/resources \
      @opentelemetry/instrumentation-user-interaction
    ```
  </TabItem>
  <TabItem value="yarn" label="Yarn" default>
    ```sh
    yarn add \
      @opentelemetry/sdk-trace-base \
      @opentelemetry/sdk-trace-web \
      @opentelemetry/exporter-trace-otlp-http \
      @opentelemetry/instrumentation \
      @opentelemetry/instrumentation-fetch \
      @opentelemetry/instrumentation-xml-http-request \
      @opentelemetry/context-zone \
      @opentelemetry/resources \
      @opentelemetry/instrumentation-user-interaction
    ```
  </TabItem>
</Tabs>

### Step 3: Create an instrumentation file

The `instrument.ts` file is required to setup the `OTLPTraceExporter` and `WebTracerProvider` which are used to capture traces within your application and export them to your collector.

```ts
import { WebTracerProvider } from '@opentelemetry/sdk-trace-web';
import { BatchSpanProcessor } from '@opentelemetry/sdk-trace-base';
import { OTLPTraceExporter } from '@opentelemetry/exporter-trace-otlp-http';
import { FetchInstrumentation } from '@opentelemetry/instrumentation-fetch';
import { registerInstrumentations } from '@opentelemetry/instrumentation';
import { resourceFromAttributes } from '@opentelemetry/resources';

const exporter = new OTLPTraceExporter({
  url: '<<SIGNOZ_COLLECTOR_URL>>/v1/traces',
});

const provider = new WebTracerProvider({
  resource: resourceFromAttributes({
    'service.name': '<<SERVICE_NAME>>',
  }),
  spanProcessors: [new BatchSpanProcessor(exporter)],
});

provider.register();

registerInstrumentations({
  instrumentations: [
    new FetchInstrumentation({
      // Selects which backend servers are allowed to receive trace headers for linking traces across services.
      // Using /.*/ acts as a wildcard. For safer usage in production, replace with specific domains:
      // e.g. propagateTraceHeaderCorsUrls: [/api\.example\.com/, /my-backend\.internal/]
      propagateTraceHeaderCorsUrls: /.*/,
    }),
    new UserInteractionInstrumentation({
      eventNames: ['click', 'input', 'submit'],
    }),
    new XMLHttpRequestInstrumentation({
      propagateTraceHeaderCorsUrls: /.*/,
    }),
  ],
});
```

Going through each of the 3 instrumentations set up:

- `FetchInstrumentation` – Automatically instruments `fetch()` API calls, capturing spans for each network request made via `fetch`. Supports propagating trace headers to backend services for distributed tracing.

- `XMLHttpRequestInstrumentation` – Instruments legacy XHR-based network requests (e.g., older libraries or custom implementations not using `fetch`). Also adds trace headers to allow backend correlation.

- `UserInteractionInstrumentation` – Tracks meaningful user actions like clicks, form inputs, and submissions. This helps correlate user intent with resulting operations like network requests or page changes.  
  For example, you can trace that a backend request was triggered by a button click.


### Step 4: Importing the instrumentation file

Import the instrumentation file at the top level of your application.

```ts
import './instrument';
import { StrictMode } from 'react';
import { createRoot } from 'react-dom/client';
import './index.css';
import App from './App.tsx';

createRoot(document.getElementById('root')!).render(
  <StrictMode>
    <App />
  </StrictMode>
);
```

### Step 5: Linking frontend traces with backend

Please follow the guide [here](https://signoz.io/docs/instrumentation/overview/) to setup traces in your backend applications.
Your frontend traces should automatically get linked with them.

For the purpose of this guide, we have setup a simple Node.js API with instrumentation.

```ts
import { NodeSDK } from '@opentelemetry/sdk-node';
import { OTLPTraceExporter } from '@opentelemetry/exporter-trace-otlp-http';
import { resourceFromAttributes } from '@opentelemetry/resources';
import { getNodeAutoInstrumentations } from '@opentelemetry/auto-instrumentations-node';

const sdk = new NodeSDK({
  resource: resourceFromAttributes({
    'service.name': '<<SERVICE_NAME>>',
  }),
  traceExporter: new OTLPTraceExporter({
    url: '<<SIGNOZ_COLLECTOR_URL>>/v1/traces',
  }),
  instrumentations: [getNodeAutoInstrumentations()],
});

sdk.start();
```

```ts
app.post('/api/generate-text', (req, res) => {
  try {
    const { length } = req.body;
    if (typeof length !== 'number' || length <= 0 || length > 10000) {
      return res.status(400).json({
        error: 'Invalid length. Please provide a number between 1 and 10000.',
      });
    }
    const generatedText = generateLoremIpsum(length);
    res.json({
      text: generatedText,
      length: generatedText.length,
      requestedLength: length,
    });
  } catch (error) {
    res.status(500).json({
      error: 'Internal server error',
    });
  }
});
```

### Step 7: Viewing Captured Traces in SigNoz

The captured traces can then be viewed in the Traces Explorer.

<figure data-zoomable align="center">
  <img
    className="box-shadowed-image"
    src="/img/guides/2025/frontend-monitoring/sending-traces/2.webp"
    alt="Viewing Network Calls"
  />
  <figcaption>
    <i>Viewing Network Calls</i>
  </figcaption>
</figure>

<figure data-zoomable align="center">
  <img
    className="box-shadowed-image"
    src="/img/guides/2025/frontend-monitoring/sending-traces/1.webp"
    alt="Viewing Distributed Traces linking frontend and backend"
  />
  <figcaption>
    <i>Viewing Distributed Traces linking frontend and backend</i>
  </figcaption>
</figure>

### Attaching additional identifiers to your Traces

You can enrich traces with additional metadata like browser type, user ID etc. to enable real user monitoring (RUM)-like insights.

To do so, you need to write a custom implementation of `SpanProcessor` which will intercept all your exported spans and attach additional attributes to them.

```ts
import { SpanProcessor } from '@opentelemetry/sdk-trace-node';
import { UAParser } from 'ua-parser-js';

export const CONSTANTS = {
  USER_ID: 'user.id',
  BROWSER_NAME: 'browser.name',
  BROWSER_VERSION: 'browser.version',
};

function getBrowserInfo() {
  // You can add your custom browser tracking logic here as well.
  // This example uses the ua-parser-js package.
  const parser = new UAParser();
  const result = parser.getResult();
  return {
    browserName: result.browser.name || '',
    browserVersion: result.browser.version || '',
    userAgent: result.ua || '',
  };
}

function getUserId() {
  // You can add your custom user ID tracking logic here as well.
  // This example uses localStorage.
  const userId = localStorage.getItem('userId');
  return {
    userId: userId || '',
  };
}

const CustomSpanProcessor: SpanProcessor = {
  onStart: span => {
    const userData = getUserId();
    const browserInfo = getBrowserInfo();

    span.setAttribute(CONSTANTS.USER_ID, userData.userId);
    span.setAttribute(CONSTANTS.BROWSER_NAME, browserInfo.browserName);
    span.setAttribute(CONSTANTS.BROWSER_VERSION, browserInfo.browserVersion);
  },
  onEnd: () => Promise.resolve(),
  forceFlush: () => Promise.resolve(),
  shutdown: () => Promise.resolve(),
};

export default CustomSpanProcessor;
```

Update your `instrument.ts` file to include this processor.

```ts
const provider = new WebTracerProvider({
  resource: resourceFromAttributes({
    'service.name': 'text-generator',
  }),
  spanProcessors: [new BatchSpanProcessor(exporter), CustomSpanProcessor],
});
```

Now every span exported will include these additional contextual attributes.

<figure data-zoomable align="center">
  <img
    className="box-shadowed-image"
    src="/img/guides/2025/frontend-monitoring/sending-traces/3.webp"
    alt="Distributed Tracing"
  />
  <figcaption>
    <i>Distributed Tracing</i>
  </figcaption>
</figure>

### Manual Instrumentation

If you need to create custom spans for capture activity, you can do so from any handler function in your code like this.

```ts
const handleSubmit = async (e: React.FormEvent) => {
  e.preventDefault();
  
  const span = tracer.startSpan('generate_text_click');

  try {
    await context.with(trace.setSpan(context.active(), span), async () => {
      const response = await fetch('/api/generate-text', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ length }),
      });

      if (!response.ok) {
        const errorData = await response.json();
        throw new Error(errorData.error || 'Failed to generate text');
      }

      const data: GenerateTextResponse = await response.json();
      setGeneratedText(data.text);
      setStats({
        length: data.length,
        requestedLength: data.requestedLength,
      });
    });
  } catch (err) {
    setError(
      err instanceof Error ? err.message : 'An unexpected error occurred'
    );
  } finally {
    span.end();
    setIsLoading(false);
  }
};
```

> You can find and try the demo application [here](https://github.com/SigNoz/frontend-monitoring-examples/tree/main/sending-traces)
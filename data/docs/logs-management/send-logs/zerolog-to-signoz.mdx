---
date: 2025-08-17
id: zerolog-to-signoz
title: Send Zerolog Logs to SigNoz
description: Learn how to send Zerolog logs with trace correlation to SigNoz for unified observability.
---

Zerolog is a high-performance, zero-allocation JSON logger for Go. This document explains how to collect log data from [Zerolog](https://github.com/rs/zerolog) with 
proper trace correlation and visualize it in SigNoz.

## Prerequisites

- A Golang application [instrumented](https://signoz.io/docs/instrumentation/opentelemetry-golang/) to send traces to SigNoz
- Application logs that are recorded to a log file

## Setup

We will be creating certain packages to correlate logs with traces by automatically injecting trace and span IDs into your log entries. Here's how the package structure will look:

```
└── pkg
    ├── context
    │   └── context.go
    ├── logger
    │   └── logger.go
    ├── middleware
    │   └── logging.go
    └── tracing
        └── tracing.go
```

### Step 1: Create a trace-aware logger

To properly correlate logs with traces, you need to create a logger that extracts trace context from requests. Create a logger package with the following structure:

**pkg/logger/logger.go**

```go:logger.go
package logger

import (
	"os"
	"time"

	"github.com/rs/zerolog"
	"go.opentelemetry.io/otel/trace"
)

var log zerolog.Logger

// Init initializes the logger to write to the console.
func Init() {
	zerolog.TimeFieldFormat = time.RFC3339
	zerolog.SetGlobalLevel(zerolog.InfoLevel)

	// Configure console writer with color
	consoleWriter := zerolog.ConsoleWriter{
		Out:        os.Stdout,
		TimeFormat: time.RFC3339,
	}

	log = zerolog.New(consoleWriter).With().Timestamp().Logger()
}

// InitWithWriter initializes the logger with a custom writer.
func InitWithWriter(writer zerolog.LevelWriter) {
	zerolog.TimeFieldFormat = time.RFC3339
	zerolog.SetGlobalLevel(zerolog.InfoLevel)

	log = zerolog.New(writer).With().Timestamp().Logger()
}

// GetLogger returns a logger instance with trace ID if available
func GetLogger(ctx trace.SpanContext) *zerolog.Logger {
	logger := log.With()

	// Add trace ID if available
	if ctx.HasTraceID() {
		logger = logger.Str("trace_id", ctx.TraceID().String())
	}

	// Add span ID if available
	if ctx.HasSpanID() {
		logger = logger.Str("span_id", ctx.SpanID().String())
	}

	l := logger.Logger()
	return &l
}

// GetGlobalLogger returns the global logger instance
func GetGlobalLogger() *zerolog.Logger {
	return &log
}
```

### Step 2: Create middleware for web frameworks

If you're using a web framework like Gin, create middleware to inject trace context into your logs:

**pkg/middleware/logging.go**

```go:logging.go
package middleware

import (
	"time"

	"golang-zerolog/pkg/logger"

	"github.com/gin-gonic/gin"
	"go.opentelemetry.io/otel/trace"
)

// LoggerKey is the key used to store the logger in the Gin context
const LoggerKey = "trace_logger"

// LoggingMiddleware returns a gin middleware that logs requests with trace information
func LoggingMiddleware() gin.HandlerFunc {
	return func(c *gin.Context) {
		// Start timer
		start := time.Now()

		// Get trace context and create logger
		spanCtx := trace.SpanContextFromContext(c.Request.Context())
		traceLogger := logger.GetLogger(spanCtx)

		// Store logger in context
		c.Set(LoggerKey, traceLogger)

		// Process request
		c.Next()

		// Log request details
		traceLogger.Info().
			Str("method", c.Request.Method).
			Str("path", c.Request.URL.Path).
			Int("status", c.Writer.Status()).
			Dur("latency", time.Since(start)).
			Str("client_ip", c.ClientIP()).
			Msg("Request processed")
	}
}
```

### Step 3: Tracing

**tracing/tracing.go**

```go:tracing.go
package tracing

import (
	"context"
	"log"
	"os"
	"strings"

	"go.opentelemetry.io/otel"
	"go.opentelemetry.io/otel/attribute"
	"go.opentelemetry.io/otel/exporters/otlp/otlptrace"
	"go.opentelemetry.io/otel/exporters/otlp/otlptrace/otlptracegrpc"
	"go.opentelemetry.io/otel/sdk/resource"
	sdktrace "go.opentelemetry.io/otel/sdk/trace"
	semconv "go.opentelemetry.io/otel/semconv/v1.4.0"
	"google.golang.org/grpc"
	"google.golang.org/grpc/credentials/insecure"
)

// InitTracer initializes the OpenTelemetry tracer
func InitTracer(serviceName string) func() {
	ctx := context.Background()

	// Get environment variables
	endpoint := os.Getenv("OTEL_EXPORTER_OTLP_ENDPOINT")
	if endpoint == "" {
		endpoint = "localhost:4317" // default endpoint
	}

	// Create OTLP exporter with non-blocking connection
	conn, err := grpc.Dial(endpoint,
		grpc.WithTransportCredentials(insecure.NewCredentials()),
		// Remove WithBlock to make it non-blocking
	)
	if err != nil {
		log.Printf("Warning: Failed to create gRPC connection to collector: %v", err)
		// Return a no-op cleanup function
		return func() {}
	}

	exporter, err := otlptrace.New(ctx, otlptracegrpc.NewClient(otlptracegrpc.WithGRPCConn(conn)))
	if err != nil {
		log.Printf("Warning: Failed to create trace exporter: %v", err)
		// Return a no-op cleanup function
		return func() {}
	}

	// Create resource with service information
	res, err := resource.New(ctx,
		resource.WithAttributes(
			semconv.ServiceNameKey.String(serviceName),
			attribute.String("environment", strings.ToLower(os.Getenv("ENV"))),
		),
	)
	if err != nil {
		log.Printf("Warning: Failed to create resource: %v", err)
		// Return a no-op cleanup function
		return func() {}
	}

	// Create trace provider
	tp := sdktrace.NewTracerProvider(
		sdktrace.WithSampler(sdktrace.AlwaysSample()),
		sdktrace.WithBatcher(exporter),
		sdktrace.WithResource(res),
	)

	// Set global trace provider
	otel.SetTracerProvider(tp)

	// Return cleanup function
	return func() {
		if err := tp.Shutdown(ctx); err != nil {
			log.Printf("Error shutting down tracer provider: %v", err)
		}
	}
}
```

### Step 4: Context

**pkg/context/context.go

```go:context.go
package context

import (
	"golang-zerolog/pkg/logger"

	"github.com/gin-gonic/gin"
	"github.com/rs/zerolog"
)

// LoggerKey is the key used to store the logger in the Gin context
const LoggerKey = "trace_logger"

// Logger returns the trace-aware logger from the Gin context
func Logger(c *gin.Context) *zerolog.Logger {
	if logger, exists := c.Get(LoggerKey); exists {
		return logger.(*zerolog.Logger)
	}
	return logger.GetGlobalLogger()
}
```

### Step 5: Using the trace aware logger in your application

```go:main.Go
import (
   // Add these as imports
	"<module-name>/pkg/context"
	"<module-name>/pkg/logger"
	"<module-name>/pkg/middleware"
	"<module-name>/pkg/tracing"
    ...
)
```

The `<module-name>` is the name of the module that you have defined in your `go.mod` file.

Utilise the trace-aware logger in your application:

```go:main.go
func main() {
	// Initialize logger
	// Configure console writer with color
	consoleWriter := zerolog.ConsoleWriter{
		Out:        os.Stdout,
		TimeFormat: time.RFC3339,
	}

	// Configure file writer
	file, err := os.OpenFile("app.log", os.O_CREATE|os.O_WRONLY|os.O_APPEND, 0666)
	if err != nil {
		log := zerolog.New(consoleWriter).With().Timestamp().Logger()
		log.Fatal().Err(err).Msg("Failed to open log file")
	}

	// Create multi-level writer
	multi := zerolog.MultiLevelWriter(consoleWriter, file)

	// Initialize logger with multi-level writer
	logger.InitWithWriter(multi)
	log := logger.GetGlobalLogger()

	// Initialize tracer
	cleanup := tracing.InitTracer("gin-zerolog-app")
	defer cleanup()

	// Create Gin router
	r := gin.New()

	// Add middlewares
	r.Use(gin.Recovery())
	r.Use(otelgin.Middleware("gin-zerolog-app")) // OpenTelemetry middleware
	r.Use(middleware.LoggingMiddleware())        // Custom logging middleware

	// // Add routes 
	// r.GET("/ping", func(c *gin.Context) {
	// 	context.Logger(c).Info().Msg("hello")
	// 	c.JSON(200, gin.H{
	// 		"message": "pong",
	// 	})
	// })

	// // Start server
	// log.Info().Msg("Starting server on :8080")
	// if err := r.Run(":8080"); err != nil {
	// 	log.Fatal().Err(err).Msg("Failed to start server")
	// }
}
```

### Step 6: Send logs to SigNoz

To send logs from your log file to SigNoz, follow this [document](https://signoz.io/docs/userguide/collect_logs_from_file/).

## Correlate logs with traces

Once you have your logs coming up in SigNoz, use the logs pipelines to extract the trace id and span id from the logs using the trace processor.

{/* Add description of how to use pipelines */}

Checkout[ this guide](https://signoz.io/docs/logs-pipelines/guides/trace/) for more details about how to extract trace information from your logs.

## Troubleshooting

### Logs not appearing in SigNoz

1. Check your ingestion key and endpoint are correct
2. Ensure your application has network access to SigNoz
3. Check for any errors in application logs

### Missing trace_id or span_id in logs

1. Ensure OpenTelemetry tracing is properly initialized
2. Verify the middleware is extracting trace context correctly
3. Check that you're using the trace-aware logger from context, not the global logger
4. Make sure the otelgin middleware is added before your logging middleware

## Example repository

For a complete working example, see: [nityanandagohain/otel-zerolog-example](https://github.com/nityanandagohain/otel-zerolog-example)

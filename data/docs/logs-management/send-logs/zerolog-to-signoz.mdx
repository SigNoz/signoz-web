---
title: Send Zerolog Logs to SigNoz
id: zerolog-to-signoz
description: Learn how to send Zerolog logs with trace correlation to SigNoz for unified observability.
---

# Zerolog Integration with OpenTelemetry

## Overview

This document explains how to collect log data from [Zerolog](https://github.com/rs/zerolog) with proper trace correlation and visualize it in [SigNoz](https://signoz.io/).

Zerolog is a high-performance, zero-allocation JSON logger for Go. When integrated with OpenTelemetry, it can automatically include trace context (trace_id and span_id) in logs, enabling powerful correlation between logs and traces in SigNoz.

## Prerequisites

- A running Golang application
- OpenTelemetry instrumentation set up for tracing (if you want trace correlation)
- SigNoz account (cloud or self-hosted)

## Setup

### Step 1: Install dependencies

Navigate to the root folder of your Golang application and run the following command to install the required dependencies:

```bash
go get \
  github.com/rs/zerolog \
  go.opentelemetry.io/contrib/bridges/otelzerolog \
  go.opentelemetry.io/otel/sdk/log \
  go.opentelemetry.io/otel/sdk/trace \
  go.opentelemetry.io/otel/trace \
  go.opentelemetry.io/otel/exporters/otlp/otlplog/otlploggrpc \
  go.opentelemetry.io/otel/exporters/otlp/otlplog/otlploghttp
```

### Step 2: Create a trace-aware logger

To properly correlate logs with traces, you need to create a logger that extracts trace context from requests. Create a logger package with the following structure:

#### logger/logger.go

```go
package logger

import (
    "os"
    "time"

    "github.com/rs/zerolog"
    "go.opentelemetry.io/otel/trace"
)

var globalLogger zerolog.Logger

// Init initializes the global logger
func Init() {
    zerolog.TimeFieldFormat = time.RFC3339
    zerolog.SetGlobalLevel(zerolog.InfoLevel)

    // Console writer for development
    output := zerolog.ConsoleWriter{
        Out:        os.Stdout,
        TimeFormat: time.RFC3339,
    }

    globalLogger = zerolog.New(output).With().Timestamp().Logger()
}

// GetLogger returns a logger with trace context
func GetLogger(ctx trace.SpanContext) *zerolog.Logger {
    logger := globalLogger.With()

    // Add trace ID if available
    if ctx.HasTraceID() {
        logger = logger.Str("trace_id", ctx.TraceID().String())
    }

    // Add span ID if available
    if ctx.HasSpanID() {
        logger = logger.Str("span_id", ctx.SpanID().String())
    }

    l := logger.Logger()
    return &l
}

// GetGlobalLogger returns the global logger instance
func GetGlobalLogger() *zerolog.Logger {
    return &globalLogger
}
```

### Step 3: Create middleware for web frameworks

If you're using a web framework like Gin, create middleware to inject trace context into your logs:

#### middleware/logging.go

```go
package middleware

import (
    "time"
    "your-app/logger"

    "github.com/gin-gonic/gin"
    "go.opentelemetry.io/otel/trace"
)

const LoggerKey = "trace_logger"

// LoggingMiddleware creates a trace-aware logger for each request
func LoggingMiddleware() gin.HandlerFunc {
    return func(c *gin.Context) {
        start := time.Now()

        // Extract trace context from request
        spanCtx := trace.SpanContextFromContext(c.Request.Context())
        traceLogger := logger.GetLogger(spanCtx)

        // Store logger in context for use in handlers
        c.Set(LoggerKey, traceLogger)

        // Process request
        c.Next()

        // Log request details with trace context
        traceLogger.Info().
            Str("method", c.Request.Method).
            Str("path", c.Request.URL.Path).
            Int("status", c.Writer.Status()).
            Dur("latency", time.Since(start)).
            Str("client_ip", c.ClientIP()).
            Msg("Request processed")
    }
}
```

### Step 4: Send logs to SigNoz via OTLP

You have two options for sending logs to SigNoz:

#### Option 1: Direct OTLP Export (Recommended)

Create an OTLP-enabled logger that sends logs directly to SigNoz:

```go
package logger

import (
    "context"
    "os"
    "time"

    "github.com/rs/zerolog"
    "go.opentelemetry.io/contrib/bridges/otelzerolog"
    "go.opentelemetry.io/otel/exporters/otlp/otlplog/otlploggrpc"
    sdklog "go.opentelemetry.io/otel/sdk/log"
    "go.opentelemetry.io/otel/sdk/resource"
    semconv "go.opentelemetry.io/otel/semconv/v1.17.0"
)

// InitWithOTLP initializes logger with OTLP export
func InitWithOTLP(serviceName string) func() {
    ctx := context.Background()

    // Create OTLP log exporter
    exporter, err := otlploggrpc.New(ctx,
        otlploggrpc.WithEndpoint(os.Getenv("OTEL_EXPORTER_OTLP_ENDPOINT")),
        otlploggrpc.WithInsecure(), // Use WithInsecure() for non-TLS endpoints
    )
    if err != nil {
        panic(err)
    }

    // Create resource with service information
    res, err := resource.New(ctx,
        resource.WithAttributes(
            semconv.ServiceNameKey.String(serviceName),
        ),
    )
    if err != nil {
        panic(err)
    }

    // Create log provider
    logProvider := sdklog.NewLoggerProvider(
        sdklog.WithBatcher(exporter),
        sdklog.WithResource(res),
    )

    // Create OTLP handler for zerolog
    otelHandler := otelzerolog.NewHandler(
        otelzerolog.WithLoggerProvider(logProvider),
    )

    // Configure multi-writer for both console and OTLP
    consoleWriter := zerolog.ConsoleWriter{
        Out:        os.Stdout,
        TimeFormat: time.RFC3339,
    }

    multi := zerolog.MultiLevelWriter(consoleWriter, otelHandler)
    
    // Update global logger
    globalLogger = zerolog.New(multi).With().Timestamp().Logger()

    // Return cleanup function
    return func() {
        if err := logProvider.Shutdown(ctx); err != nil {
            panic(err)
        }
    }
}
```

#### Option 2: File-based Collection via OpenTelemetry Collector

If you prefer to collect logs from files, first configure your logger to write to a file:

```go
func InitWithFile() {
    logFile, err := os.OpenFile("application.log", 
        os.O_APPEND|os.O_CREATE|os.O_WRONLY, 0644)
    if err != nil {
        panic(err)
    }

    // Write to both console and file
    multi := zerolog.MultiLevelWriter(
        zerolog.ConsoleWriter{Out: os.Stdout, TimeFormat: time.RFC3339},
        logFile,
    )
    
    globalLogger = zerolog.New(multi).With().Timestamp().Logger()
}
```

Then configure OpenTelemetry Collector to read the log file:

```yaml
receivers:
  filelog:
    include: ["./application.log"]
    start_at: beginning
    operators:
      - type: json_parser
        timestamp:
          parse_from: attributes.time
          layout: '%Y-%m-%dT%H:%M:%S%z'
      - type: trace_parser
        trace_id:
          parse_from: attributes.trace_id
        span_id:
          parse_from: attributes.span_id
      - type: move
        from: attributes.message
        to: body

processors:
  batch:
    send_batch_size: 1000
    timeout: 10s

exporters:
  otlp:
    endpoint: "ingest.<region>.signoz.cloud:443"
    tls:
      insecure: false
    headers:
      "signoz-ingestion-key": "<your-ingestion-key>"

service:
  pipelines:
    logs:
      receivers: [filelog]
      processors: [batch]
      exporters: [otlp]
```

### Step 5: Using the trace-aware logger in your application

#### main.go

```go
package main

import (
    "your-app/logger"
    "your-app/middleware"
    
    "github.com/gin-gonic/gin"
    "go.opentelemetry.io/contrib/instrumentation/github.com/gin-gonic/gin/otelgin"
)

func main() {
    // Initialize logger with OTLP export
    logCleanup := logger.InitWithOTLP("your-service-name")
    defer logCleanup()
    
    log := logger.GetGlobalLogger()

    // Initialize your OpenTelemetry tracer
    // ... tracer initialization code ...

    // Create Gin router
    r := gin.New()

    // Add OpenTelemetry middleware for tracing
    r.Use(otelgin.Middleware("your-service-name"))
    
    // Add logging middleware for trace correlation
    r.Use(middleware.LoggingMiddleware())

    // Define routes
    r.GET("/ping", func(c *gin.Context) {
        // Get trace-aware logger from context
        logger := c.MustGet(middleware.LoggerKey).(*zerolog.Logger)
        
        // Use the logger - it automatically includes trace_id and span_id
        logger.Info().Msg("Processing ping request")
        
        c.JSON(200, gin.H{
            "message": "pong",
        })
    })

    // Start server
    log.Info().Msg("Starting server on :8080")
    if err := r.Run(":8080"); err != nil {
        log.Fatal().Err(err).Msg("Failed to start server")
    }
}
```

### Step 6: Run your application

To send logs to SigNoz Cloud:

```bash
OTEL_EXPORTER_OTLP_ENDPOINT="ingest.<region>.signoz.cloud:443" \
OTEL_EXPORTER_OTLP_HEADERS="signoz-ingestion-key=<your-ingestion-key>" \
go run main.go
```

Replace:
- `<region>` with your SigNoz Cloud region (us, eu, or in)
- `<your-ingestion-key>` with your actual ingestion key

For self-hosted SigNoz:

```bash
OTEL_EXPORTER_OTLP_ENDPOINT="<your-otel-collector>:4317" \
go run main.go
```

## Viewing correlated logs in SigNoz

1. Navigate to the **Logs** tab in SigNoz
2. You should see logs with `trace_id` and `span_id` fields
3. Click on any log entry to see details
4. Use the "View in Traces" button to jump to the associated trace
5. From the Traces view, you can also see all related logs

![Zerolog logs with trace correlation](/img/docs/logs-management/send-logs/zerolog-trace-correlation.webp)

## Troubleshooting

### Logs not appearing in SigNoz

1. Check your ingestion key and endpoint are correct
2. Verify OpenTelemetry Collector is running (if using file-based collection)
3. Ensure your application has network access to SigNoz
4. Check for any errors in application logs

### Missing trace_id or span_id in logs

1. Ensure OpenTelemetry tracing is properly initialized
2. Verify the middleware is extracting trace context correctly
3. Check that you're using the trace-aware logger from context, not the global logger

### Performance considerations

- Zerolog is designed for high performance with zero allocations
- Use batch processing in OpenTelemetry Collector for better throughput
- Consider log sampling for high-volume applications
- File-based collection may have slightly higher latency than direct OTLP export

## Example repository

For a complete working example, see: [nityanandagohain/otel-zerolog-example](https://github.com/nityanandagohain/otel-zerolog-example)

## Further reading

- [Zerolog Documentation](https://github.com/rs/zerolog)
- [OpenTelemetry Go Documentation](https://opentelemetry.io/docs/languages/go/)
- [SigNoz Logs Documentation](https://signoz.io/docs/userguide/logs/)

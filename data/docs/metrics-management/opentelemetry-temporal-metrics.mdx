---
date: 2025-03-03
title: Temporal Metrics using OpenTelemetry
id: opentelemetry-temporal-metrics
description: Learn how to instrument Temporal applications to send metrics to SigNoz using OpenTelemetry
---

import InstrumentationFAQ from '@/components/shared/instrumentation-faq.md'

This document contains instructions on how to set up OpenTelemetry instrumentation in your Temporal applications and view your application metrics in SigNoz.

## Requirements

- Temporal server (self-hosted or Cloud)
- Java 11+, Go 1.19+, or Node.js 16+ depending on your application
- Temporal application

## Temporal Server Setup

<Tabs>
<TabItem value="temporal-self-hosted" label="Self-Hosted Temporal" default>

1. Install [Temporal CLI](https://github.com/temporalio/cli/releases)

2. Start the development server:
```bash
temporal server start-dev --ui-port 8080
```

This starts:
- Temporal Server on port 7233
- Web UI on port 8080 (http://localhost:8080)
- Default namespace: "default"

<figure data-zoomable align='center'>
    <img src="/img/docs/instrumentation/temporal-self-hosted-ui.webp" alt="Temporal Web UI Dashboard"/>
    <figcaption><i>Temporal Self-Hosted UI</i></figcaption>
</figure>

<figure data-zoomable align='center'>
    <img src="/img/docs/instrumentation/temporal-self-hosted-traces.webp" alt="Temporal Traces"/>
    <figcaption><i>Temporal Traces</i></figcaption>
</figure>

</TabItem>

<TabItem value="temporal-cloud" label="Temporal Cloud">

1. Install [Temporal CLI](https://github.com/temporalio/cli/releases)

2. **Generate mTLS Certificate**
- Go to Temporal Cloud Console and follow the [generation instructions](https://docs.temporal.io/cloud/certificates) or use your own certificates following [Temporal's requirements](https://docs.temporal.io/cloud/certificates#certificate-requirements)

3. **Create Namespace**
- Create a namespace in Temporal Cloud Console (e.g., default, dev-namespace, prod-namespace)

4. **Verify Connection**
```bash
temporal workflow list \
  --address <namespace>.<account_id>.tmprl.cloud:7233 \
  --namespace <namespace>.<account_id> \
  --tls-cert-path <cert.pem> \
  --tls-key-path <cert.key>
```
This command should return an empty response for a new namespace.

5. **Configure Environment**
```bash
# Temporal Cloud
export TEMPORAL_HOST_URL=<namespace>.<account_id>.tmprl.cloud:7233
export TEMPORAL_NAMESPACE=<namespace>.<account_id>
export TEMPORAL_TLS_CERT=<cert.pem>
export TEMPORAL_TLS_KEY=<cert.key>
```

<figure data-zoomable align='center'>
    <img src="/img/docs/instrumentation/temporal-cloud-ui.webp" alt="Temporal Cloud UI Dashboard"/>
    <figcaption><i>Temporal Cloud UI</i></figcaption>
</figure>

<figure data-zoomable align='center'>
    <img src="/img/docs/instrumentation/temporal-cloud-traces.webp" alt="Temporal Cloud Traces"/>
    <figcaption><i>Temporal Cloud Traces</i></figcaption>
</figure>
</TabItem>
</Tabs>

## Implementation

<Tabs>
<TabItem value="signoz-self-host" label="Self-Hosted SigNoz" default>
<Tabs>
<TabItem value="java" label="Java" default>

### Step 1: Add OpenTelemetry Dependencies

Add to your `pom.xml`:

```xml
<properties>
    <opentelemetry.version>1.34.1</opentelemetry.version>
    <temporal.version>1.24.1</temporal.version>
</properties>

<dependencies>
    <!-- Temporal -->
    <dependency>
        <groupId>io.temporal</groupId>
        <artifactId>temporal-sdk</artifactId>
        <version>${temporal.version}</version>
    </dependency>
    <dependency>
        <groupId>io.temporal</groupId>
        <artifactId>temporal-opentracing</artifactId>
        <version>${temporal.version}</version>
    </dependency>

    <!-- OpenTelemetry -->
    <dependency>
        <groupId>io.opentelemetry</groupId>
        <artifactId>opentelemetry-api</artifactId>
        <version>${opentelemetry.version}</version>
    </dependency>
    <dependency>
        <groupId>io.opentelemetry</groupId>
        <artifactId>opentelemetry-sdk</artifactId>
        <version>${opentelemetry.version}</version>
    </dependency>
    <dependency>
        <groupId>io.opentelemetry</groupId>
        <artifactId>opentelemetry-exporter-otlp</artifactId>
        <version>${opentelemetry.version}</version>
    </dependency>
    <dependency>
        <groupId>io.opentelemetry</groupId>
        <artifactId>opentelemetry-extension-trace-propagators</artifactId>
        <version>${opentelemetry.version}</version>
    </dependency>
</dependencies>
```

### Step 2: Configure OpenTelemetry

Create `SignozTelemetryUtils.java` to configure OpenTelemetry with SigNoz OTLP exporter, trace propagation, and Temporal interceptors:

```java:src/main/java/helloworld/config/SignozTelemetryUtils.java
package helloworld.config;

import com.uber.m3.tally.Scope;
import io.opentelemetry.api.OpenTelemetry;
import io.opentelemetry.api.metrics.Meter;
import io.opentelemetry.api.trace.Tracer;
import io.opentelemetry.context.propagation.ContextPropagators;
import io.opentelemetry.api.trace.propagation.W3CTraceContextPropagator;
import io.opentelemetry.sdk.OpenTelemetrySdk;
import io.opentelemetry.sdk.resources.Resource;
import io.temporal.common.interceptors.WorkerInterceptor;
import java.util.logging.Level;
import java.util.logging.Logger;

public class SignozTelemetryUtils {
    private static final Logger logger = Logger.getLogger(SignozTelemetryUtils.class.getName());
    private static volatile boolean initialized = false;
    private static Meter meter;
    private static Tracer tracer;
    
    public static synchronized void initializeTelemetry() {
        if (initialized) {
            return;
        }
        
        logger.info("Initializing OpenTelemetry...");
        
        try {
            // Create resource with service info
            Resource resource = OpenTelemetryConfig.createResource();
            
            // Build SDK with metrics and tracing support
            OpenTelemetrySdk sdk = OpenTelemetrySdk.builder()
                .setTracerProvider(TracingExporter.createTracerProvider())
                .setMeterProvider(MetricsExporter.createMeterProvider())
                .setPropagators(ContextPropagators.create(W3CTraceContextPropagator.getInstance()))
                .build();
            
            OpenTelemetryConfig.setOpenTelemetry(sdk);
            
            // Initialize meters and tracers
            meter = sdk.getMeter("io.temporal");
            tracer = sdk.getTracer("io.temporal");
            
            // Initialize workflow metrics for the dashboard
            WorkflowMetricsUtil.initializeMetrics();
            
            // Add shutdown hook for clean telemetry shutdown
            Runtime.getRuntime().addShutdownHook(new Thread(() -> {
                logger.info("Shutting down OpenTelemetry...");
                
                // First, clean up WorkflowMetricsUtil resources
                WorkflowMetricsUtil.cleanup();
                
                // Force metrics export before shutdown
                try {
                    // Allow time for any pending metrics to be exported
                    Thread.sleep(500);
                } catch (InterruptedException e) {
                    logger.log(Level.WARNING, "Interrupted during shutdown delay", e);
                }
                
                // Shutdown exporters
                TracingExporter.shutdown();
                MetricsExporter.shutdown();
                
                // Reset local references
                meter = null;
                tracer = null;
                initialized = false;
            }));
            
            initialized = true;
            logger.info("OpenTelemetry initialization complete");
        } catch (Exception e) {
            logger.log(Level.SEVERE, "Error initializing OpenTelemetry", e);
        }
    }
    
    public static Meter getMeter() {
        if (!initialized) {
            logger.warning("OpenTelemetry not initialized. Call initializeTelemetry() first.");
        }
        return meter;
    }
    
    public static Tracer getTracer() {
        if (!initialized) {
            logger.warning("OpenTelemetry not initialized. Call initializeTelemetry() first.");
        }
        return tracer;
    }
    
    public static Scope getMetricsScope() {
        return MetricsExporter.getMetricsScope();
    }

    public static WorkerInterceptor getWorkerInterceptor() {
        return TracingExporter.getWorkerInterceptor();
    }
    
    private SignozTelemetryUtils() {
        // Prevent instantiation - use static methods
    }
}
```

### Step 3: Configure OpenTelemetry Settings

Create `OpenTelemetryConfig.java` to manage OpenTelemetry configuration including service attributes, resource settings, and endpoint configuration. This class will be used by the telemetry utilities to initialize the OpenTelemetry SDK.

```java:src/main/java/helloworld/config/OpenTelemetryConfig.java
package helloworld.config;

import io.opentelemetry.api.OpenTelemetry;
import io.opentelemetry.api.common.Attributes;
import io.opentelemetry.api.common.AttributeKey;
import io.opentelemetry.api.trace.propagation.W3CTraceContextPropagator;
import io.opentelemetry.context.propagation.ContextPropagators;
import io.opentelemetry.sdk.OpenTelemetrySdk;
import io.opentelemetry.sdk.resources.Resource;
import io.temporal.client.WorkflowClient;
import io.temporal.serviceclient.WorkflowServiceStubs;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.HashMap;
import java.util.Map;

public final class OpenTelemetryConfig {
    private static final Logger logger = Logger.getLogger(OpenTelemetryConfig.class.getName());

    // Default values used when environment variables are not set
    public static final String DEFAULT_SIGNOZ_ENDPOINT = "http://localhost:4317";

    //OpenTelemetry resource attribute keys for custom attribute creation
    public static final AttributeKey<String> SERVICE_NAME = AttributeKey.stringKey("service.name");
    public static final AttributeKey<String> ACCESS_TOKEN = AttributeKey.stringKey("signoz-access-token");
    public static final AttributeKey<String> SERVICE_NAMESPACE = AttributeKey.stringKey("service.namespace");
    public static final AttributeKey<String> DEPLOYMENT_ENVIRONMENT = AttributeKey.stringKey("deployment.environment");

    // Environment variables for configuration override
    private static final String ENV_OTEL_ENDPOINT = "OTEL_EXPORTER_OTLP_ENDPOINT";  // Collector endpoint
    private static final String ENV_ENVIRONMENT = "OTEL_ENVIRONMENT";               // Deployment environment
    private static final String ENV_RESOURCE_ATTRIBUTES = "OTEL_RESOURCE_ATTRIBUTES"; // Resource attributes
    private static final String ENV_SIGNOZ_ACCESS_TOKEN = "OTEL_EXPORTER_OTLP_HEADERS"; // SigNoz access token

    // Global SDK instance - initialized by SignozTelemetryUtils
    private static volatile OpenTelemetry openTelemetry;
    private static WorkflowServiceStubs service;
    private static WorkflowClient client;
    private static volatile Resource resource;

    public static OpenTelemetry getOpenTelemetry() {
        if (openTelemetry == null) {
            throw new IllegalStateException("OpenTelemetry not initialized. Call initialize() first.");
        }
        return openTelemetry;
    }

    public static Resource createResource() {
        if (resource != null) {
            return resource;
        }

        synchronized (OpenTelemetryConfig.class) {
            if (resource != null) {
                return resource;
            }

            String environment = System.getenv().getOrDefault(ENV_ENVIRONMENT, "development");
            
            // Parse OTEL_RESOURCE_ATTRIBUTES
            String resourceAttrs = System.getenv(ENV_RESOURCE_ATTRIBUTES);
            Map<AttributeKey<String>, String> attributes = new HashMap<>();
            
            if (resourceAttrs != null) {
                // Parse comma-separated key-value pairs
                for (String pair : resourceAttrs.split(",")) {
                    String[] keyValue = pair.trim().split("=", 2);
                    if (keyValue.length == 2) {
                        String key = keyValue[0].trim();
                        String value = keyValue[1].trim();
                        if ("service.name".equals(key)) {
                            attributes.put(SERVICE_NAME, value);
                        }
                    }
                }
            }

            // Verify service.name is set
            if (!attributes.containsKey(SERVICE_NAME)) {
                throw new IllegalStateException(
                    "service.name must be configured via OTEL_RESOURCE_ATTRIBUTES environment variable. " +
                    "Example: OTEL_RESOURCE_ATTRIBUTES=service.name=your-service-name"
                );
            }

            // Create resource with attributes
            resource = Resource.create(
                Attributes.of(
                    SERVICE_NAME, attributes.get(SERVICE_NAME),
                    SERVICE_NAMESPACE, "default",
                    DEPLOYMENT_ENVIRONMENT, environment
                )
            );
            
            logger.info("Creating resource with service.name: " + attributes.get(SERVICE_NAME));
            logger.info("Environment: " + environment);
            logger.info("Resource attributes: " + resourceAttrs);
            
            return Resource.getDefault().merge(resource);
        }
    }

    public static String getEndpoint() {
        String endpoint = System.getenv().getOrDefault(ENV_OTEL_ENDPOINT, DEFAULT_SIGNOZ_ENDPOINT);
        
        // Ensure the endpoint starts with a protocol
        if (!endpoint.startsWith("http://") && !endpoint.startsWith("https://")) {
            endpoint = "http://" + endpoint;
        }
        
        return endpoint;
    }

    public static String getAccessToken() {
        return System.getenv().get(ENV_SIGNOZ_ACCESS_TOKEN);
    }

    public static String getResourceAttributes() {
        return System.getenv().get(ENV_RESOURCE_ATTRIBUTES);
    }

    public static String getServiceName() {
        String resourceAttrs[] = System.getenv(ENV_RESOURCE_ATTRIBUTES).split(",");
        for (String pair : resourceAttrs) {
            String[] keyValue = pair.trim().split("=", 2);
            if ("service.name".equals(keyValue[0].trim())) {
                return keyValue[1].trim();
            }
        }
        return "temporal-hello-world";
    }

    protected static synchronized void setOpenTelemetry(OpenTelemetrySdk sdk) {
        if (openTelemetry != null) {
            throw new IllegalStateException("OpenTelemetry already initialized");
        }
        openTelemetry = sdk;
    }

    private OpenTelemetryConfig() {
        // Prevent instantiation - use static methods
    }
}
```

### Step 4: Set Up Metrics Export

Create `MetricsExporter.java` to configure metrics export to SigNoz with OTLP/gRPC, batch processing, and Temporal metrics:

```java:src/main/java/helloworld/config/MetricsExporter.java
package helloworld.config;

import io.opentelemetry.exporter.otlp.metrics.OtlpGrpcMetricExporter;
import io.opentelemetry.sdk.metrics.SdkMeterProvider;
import io.opentelemetry.sdk.metrics.export.PeriodicMetricReader;
import io.opentelemetry.sdk.metrics.InstrumentSelector;
import io.opentelemetry.sdk.metrics.View;
import com.uber.m3.tally.NoopScope;
import com.uber.m3.tally.Scope;
import java.util.logging.Logger;
import java.util.concurrent.TimeUnit;

public class MetricsExporter {
    private static final Logger logger = Logger.getLogger(MetricsExporter.class.getName());
    private static Scope metricsScope;
    private static PeriodicMetricReader metricReader;

    public static synchronized Scope getMetricsScope() {
        if (metricsScope == null) {
            metricsScope = new NoopScope();
        }
        return metricsScope;
    }

    public static SdkMeterProvider createMeterProvider() {
        String endpoint = OpenTelemetryConfig.getEndpoint();
        String accessToken = OpenTelemetryConfig.getAccessToken();
        
        // Parse the header key and value
        String headerKey = null;
        String headerValue = accessToken;
        if (accessToken != null && accessToken.contains("=")) {
            String[] parts = accessToken.split("=", 2);
            headerKey = parts[0];
            headerValue = parts[1];
        }

        // Create OTLP metric exporter
        OtlpGrpcMetricExporter metricExporter;
        if (headerKey != null && headerValue != null && !headerValue.isEmpty()) {
            logger.info("Metrics header key: " + headerKey);
            logger.info("Metrics endpoint: " + endpoint);
            metricExporter = OtlpGrpcMetricExporter.builder()
                .setEndpoint(endpoint)
                .addHeader(headerKey, headerValue)
                .setTimeout(java.time.Duration.ofSeconds(60))
                .build();
        } else {
            metricExporter = OtlpGrpcMetricExporter.builder()
                .setEndpoint(endpoint)
                .setTimeout(java.time.Duration.ofSeconds(60))
                .build();
        }

        // Create metric reader with optimized settings
        metricReader = PeriodicMetricReader.builder(metricExporter)
            .setInterval(java.time.Duration.ofSeconds(1))  // More frequent updates for better visibility
            .build();

        // Create views for workflow metrics
        View workflowStartedView = View.builder()
            .setName("workflow_started_count_total")
            .setDescription("Total number of workflow executions started")
            .setAggregation(io.opentelemetry.sdk.metrics.Aggregation.sum())
            .build();

        View workflowCompletedView = View.builder()
            .setName("workflow_completed_count_total")
            .setDescription("Total number of workflow executions completed")
            .setAggregation(io.opentelemetry.sdk.metrics.Aggregation.sum())
            .build();

        // Create and return meter provider with views
        return SdkMeterProvider.builder()
            .setResource(OpenTelemetryConfig.createResource())
            .registerMetricReader(metricReader)
            .registerView(
                InstrumentSelector.builder()
                    .setName("workflow_started_count_total")
                    .build(),
                workflowStartedView)
            .registerView(
                InstrumentSelector.builder()
                    .setName("workflow_completed_count_total")
                    .build(),
                workflowCompletedView)
            .build();
    }

    public static void shutdown() {
        if (metricReader != null) {
            try {
                logger.info("Shutting down metrics reader...");
                
                // First flush any pending metrics
                try {
                    metricReader.forceFlush().join(10, TimeUnit.SECONDS);
                    logger.info("Metrics flush completed");
                } catch (Exception e) {
                    logger.warning("Metrics flush failed: " + e.getMessage());
                }
                
                // Then shutdown the reader
                try {
                    metricReader.shutdown().join(10, TimeUnit.SECONDS);
                    logger.info("Metrics reader shutdown completed successfully");
                } catch (Exception e) {
                    logger.warning("Metrics reader shutdown failed: " + e.getMessage());
                }
            } catch (Exception e) {
                logger.severe("Error during metrics reader shutdown: " + e.getMessage());
            } finally {
                metricReader = null;
                metricsScope = null;
            }
        }
    }

    private MetricsExporter() {
        // Prevent instantiation - use static methods
    }
}
```

### Step 5: Configure Worker with Metrics

Configure your Temporal Worker to initialize and integrate OpenTelemetry metrics collection:

```java:src/main/java/helloworld/workers/HelloWorldWorker.java
public class HelloWorldWorker implements AutoCloseable {
    ...

    public HelloWorldWorker() {
        // Initialize OpenTelemetry SDK for metrics collection
        SignozTelemetryUtils.initializeTelemetry();

        // Configure Temporal client to expose metrics through OpenTelemetry
        WorkflowServiceStubsOptions stubOptions = WorkflowServiceStubsOptions.newBuilder()
            .setMetricsScope(SignozTelemetryUtils.getMetricsScope()) // Get OTEL metrics context
            .build();

        // Enable workflow-level metric tracking via interceptor
        WorkerFactoryOptions factoryOptions = WorkerFactoryOptions.newBuilder()
            .setWorkerInterceptors(SignozTelemetryUtils.getWorkerInterceptor()) // Metrics collection hook
            .build();

        ... //Temporal worker initialization
    }

    public void start() {
        try {
            ... // worker startup
            
            // Register custom metric definitions (counter/gauges/histograms)
            TemporalConfig.registerDashboardMetrics();
            
            ... //shutdown hook setup
        } catch (Exception e) {
            ... // Error handling
        }
    }

    @Override
    public void close() {
        ... // Temporal shutdown logic
        
        try {            
            // Release metric resources before shutdown
            helloworld.config.WorkflowMetricsUtil.cleanup();
            
            // Flush remaining metric data to exporter
            SignozTelemetryUtils.getMetricsScope().close();
            
            // Allow buffer time for final metric exports
            Thread.sleep(1000);
            
            // Shutdown metrics export pipeline
            MetricsExporter.shutdown();

            ... // Remaining cleanup
        } catch (Exception e) {
            ... // Error handling
        }
    }
}
```

### Step 6: Configure Workflow Starter
Update your Temporal Workflow Starter to initialize OpenTelemetry for metrics:

```java:src/main/java/helloworld/main/HelloWorldStarter.java
public class HelloWorldStarter {
    ...

    public HelloWorldStarter() {
        // 1. Initialize OpenTelemetry metrics collection
        SignozTelemetryUtils.initializeTelemetry();

        // 2. Create metrics instruments
        Meter meter = SignozTelemetryUtils.getMeter();
        workflowCompletionCounter = meter
            .counterBuilder("workflow_completed_count_total")
            .setDescription("Tracks total completed workflows")
            .build();
            
        workflowStartCounter = meter
            .counterBuilder("workflow_started_count_total")
            .setDescription("Tracks total initiated workflows")
            .build();

        // 3. Attach metrics collection to Temporal client
        WorkflowServiceStubsOptions stubOptions = WorkflowServiceStubsOptions.newBuilder()
            .setMetricsScope(SignozTelemetryUtils.getMetricsScope()) // Connect OTEL metrics
            .build();

        ... // Rest ofclient setup
    }

    public void runWorkflow(String name) {
        ... //workflow setup
        
        try {
            // 4. Record workflow initiation metric
            workflowStartCounter.add(1L);
            
            ... // Workflow execution logic
            
            // 5. Record successful completion metric
            workflowCompletionCounter.add(1L);
            WorkflowMetricsUtil.recordSuccess(...);
            
        } catch (Exception e) {
            // 6. Record failure metric
            WorkflowMetricsUtil.recordFailure(...);
            ...
        } finally {
            // 7. Ensure metrics export cleanup
            MetricsExporter.shutdown();
            Thread.sleep(1000); // Allow final metric flush
            ...
        }
    }

    ... // Main method
}
```

### Step 7: Configure Environment
Set up your environment variables for Signoz.

```bash
# SigNoz endpoint
OTEL_EXPORTER_OTLP_ENDPOINT=http://localhost:4317

# Set service name and other attributes
OTEL_RESOURCE_ATTRIBUTES="service.name=temporal-hello-world"
```

### Step 8: Run Application

1. Start the worker:
```bash
mvn exec:java -Dexec.mainClass="helloworld.workers.HelloWorldWorker"
```

2. Execute workflows to generate metrics in another terminal:
```bash
mvn exec:java -Dexec.mainClass="helloworld.main.HelloWorldStarter"
```

</TabItem>

<TabItem value="typescript" label="TypeScript">

### Step 1: Add OpenTelemetry Dependencies

Add the following dependencies to your `package.json`:

```json
{
  "dependencies": {
    "@grpc/grpc-js": "^1.9.0",
    "@opentelemetry/api": "^1.7.0", 
    "@opentelemetry/auto-instrumentations-node": "^0.56.1",
    "@opentelemetry/core": "^1.19.0",
    "@opentelemetry/exporter-metrics-otlp-grpc": "^0.46.0",
    "@opentelemetry/exporter-metrics-otlp-http": "^0.57.2",
    "@opentelemetry/exporter-trace-otlp-grpc": "^0.46.0",
    "@opentelemetry/exporter-trace-otlp-http": "^0.57.2",
    "@opentelemetry/exporter-trace-otlp-proto": "^0.57.2",
    "@opentelemetry/instrumentation": "^0.46.0",
    "@opentelemetry/resources": "^1.19.0",
    "@opentelemetry/sdk-metrics": "^1.19.0",
    "@opentelemetry/sdk-node": "^0.46.0",
    "@opentelemetry/sdk-trace-base": "^1.19.0",
    "@opentelemetry/sdk-trace-node": "^1.19.0",
    "@opentelemetry/semantic-conventions": "^1.19.0",
    "@temporalio/client": "^1.9.0",
    "@temporalio/common": "^1.9.0",
    "@temporalio/interceptors-opentelemetry": "^1.11.7",
    "@temporalio/worker": "^1.9.0",
    "@temporalio/workflow": "^1.9.0",
    "nanoid": "^5.1.4"
  }
}
```

### Step 2: Configure OpenTelemetry Utilities

Create `signozTelemetryUtils.ts` to manage OpenTelemetry SDK lifecycle and provide access to tracer and meter instances for SigNoz integration:

```typescript:src/config/signozTelemetryUtils.ts
import { diag, trace, metrics, Tracer, Meter } from '@opentelemetry/api';
import { NodeSDK } from '@opentelemetry/sdk-node';

// Persistent SDK and telemetry instances
let sdkInstance: NodeSDK | null = null;
let tracerInstance: Tracer | null = null;
let meterInstance: Meter | null = null;
let initialized = false;

export function getTracer(): Tracer {
    if (!tracerInstance) {
        tracerInstance = trace.getTracer('temporal-hello-world');
    }
    return tracerInstance;
}

export function getMeter(): Meter {
    if (!meterInstance) {
        meterInstance = metrics.getMeter('temporal-hello-world');
    }
    return meterInstance;
}

export function initializeTelemetry(): void {
    if (initialized) {
        return;
    }
    
    diag.info("Initializing OpenTelemetry...");
    
    try {
        // SDK initialization handled in opentelemetryConfig.ts
        
        // Create instances for later use
        tracerInstance = getTracer();
        meterInstance = getMeter();
        
        initialized = true;
        diag.info("OpenTelemetry initialized successfully");
    } catch (error) {
        diag.error(`Error initializing OpenTelemetry: ${error}`);
    }
}

export async function shutdownTelemetry(): Promise<void> {
    if (!sdkInstance) {
        return;
    }
    
    try {
        diag.info("Shutting down OpenTelemetry SDK...");
        await sdkInstance.shutdown();
        sdkInstance = null;
        tracerInstance = null;
        meterInstance = null;
        initialized = false;
        diag.info("OpenTelemetry SDK shut down successfully");
    } catch (error) {
        diag.error(`Error shutting down OpenTelemetry SDK: ${error}`);
    }
}

export function getSDK(): NodeSDK | null {
    return sdkInstance;
}

export function setSDK(sdk: NodeSDK): void {
    sdkInstance = sdk;
}

export async function forceSpanExport(): Promise<boolean> {
    if (!sdkInstance) {
        return false;
    }
        
    // Create a promise that times out after 5 seconds
    const timeoutPromise = new Promise<boolean>((resolve) => {
        setTimeout(() => {
            diag.warn('Span export timed out after 5 seconds');
            resolve(false);
        }, 5000);
    });
    
    // Create a promise for the shutdown
    const shutdownPromise = sdkInstance.shutdown().then(() => {
        diag.info('SDK shutdown complete, spans exported');
        // Reset instances after shutdown
        sdkInstance = null;
        tracerInstance = null;
        meterInstance = null;
        initialized = false;
        return true;
    }).catch(err => {
        diag.error('Error during SDK shutdown:', err);
        return false;
    });
    
    // Return the first promise that resolves
    return Promise.race([shutdownPromise, timeoutPromise]);
}

export function getServiceName(defaultServiceName: string = 'temporal-typescript-app'): string {
  if (process.env.OTEL_SERVICE_NAME) {
    return process.env.OTEL_SERVICE_NAME;
  }

  // Try to extract from OTEL_RESOURCE_ATTRIBUTES
  const resourceAttrs = process.env.OTEL_RESOURCE_ATTRIBUTES || '';
  const serviceNameMatch = resourceAttrs.match(/service\.name=([^,]+)/);
  
  if (serviceNameMatch && serviceNameMatch[1]) {
    return serviceNameMatch[1].trim();
  }
  
  return defaultServiceName;
}

// Export default object with all methods
export default {
    getTracer,
    getMeter,
    initializeTelemetry,
    shutdownTelemetry,
    forceSpanExport,
    getSDK,
    setSDK
};
```

### Step 3: Configure OpenTelemetry Metrics Exporter

Create `metricExporter.ts` to configure the metrics exporter:

```typescript:src/config/metricsExporter.ts
import { diag } from '@opentelemetry/api';
import { OTLPMetricExporter } from '@opentelemetry/exporter-metrics-otlp-grpc';
import { PeriodicExportingMetricReader, MetricReader } from '@opentelemetry/sdk-metrics';

export function configureMetricsEnvironment(): void {
    // Configure environment variables for metrics if not already set
    if (!process.env.OTEL_METRICS_EXPORTER) {
        process.env.OTEL_METRICS_EXPORTER = 'otlp';
    }
    
    if (!process.env.OTEL_EXPORTER_OTLP_PROTOCOL) {
        process.env.OTEL_EXPORTER_OTLP_PROTOCOL = 'grpc';
    }
    
    if (!process.env.OTEL_EXPORTER_OTLP_METRICS_ENDPOINT && process.env.OTEL_EXPORTER_OTLP_ENDPOINT) {
        process.env.OTEL_EXPORTER_OTLP_METRICS_ENDPOINT = process.env.OTEL_EXPORTER_OTLP_ENDPOINT;
    }
    
    process.env.OTEL_EXPORTER_OTLP_METRICS_TEMPORALITY_PREFERENCE = 'cumulative';
}

export function getMetricsReader(options?: { intervalMillis?: number }): MetricReader {
    const endpoint = process.env.OTEL_EXPORTER_OTLP_ENDPOINT || 'http://localhost:4317';
    const intervalMillis = options?.intervalMillis || 5000;
    
    console.log(`[METRICS] Configuring metrics reader with endpoint ${endpoint} and interval ${intervalMillis}ms`);
    
    // Get OpenTelemetry headers from environment variables
    const headers = getOtelHeaders();
    const headerKeys = Object.keys(headers);
    if (headerKeys.length > 0) {
        console.log(`[METRICS] Using headers: ${headerKeys.join(', ')}`);
    }
    
    // Create OTLP gRPC exporter
    const exporter = new OTLPMetricExporter({
        url: endpoint,
        timeoutMillis: 15000,
        headers: headers // Include any headers from env variables
    });
    
    // Create periodic reader with configured interval
    const reader = new PeriodicExportingMetricReader({
        exporter,
        exportIntervalMillis: intervalMillis,
        exportTimeoutMillis: Math.floor(intervalMillis * 0.8) // Set timeout to 80% of interval to ensure it's always less
    });
    
    return reader;
}

export function getOtelHeaders(): Record<string, string> {
    const headers: Record<string, string> = {};
    
    // Extract headers from environment variables
    Object.keys(process.env).forEach(key => {
        if (key.startsWith('OTEL_EXPORTER_OTLP_HEADERS_')) {
            const headerName = key.replace('OTEL_EXPORTER_OTLP_HEADERS_', '').toLowerCase();
            headers[headerName] = process.env[key] || '';
        }
    });
    
    return headers;
}

export default {
    getMetricsReader,
    getOtelHeaders,
    configureMetricsEnvironment
};
```

### Step 4: Configure OpenTelemetry SDK

Create `opentelemetryConfig.ts` to initialize the OpenTelemetry SDK:

```typescript:src/config/opentelemetryConfig.ts
import { Runtime } from '@temporalio/worker';
import { NodeSDK } from '@opentelemetry/sdk-node';
import { Resource } from '@opentelemetry/resources';
import { ATTR_SERVICE_NAME } from '@opentelemetry/semantic-conventions';
import { diag, DiagConsoleLogger, DiagLogLevel } from '@opentelemetry/api';
import { CompositePropagator, W3CTraceContextPropagator, W3CBaggagePropagator } from '@opentelemetry/core';
import { getNodeAutoInstrumentations } from '@opentelemetry/auto-instrumentations-node';
import { getMetricsReader } from './metricsExporter';
import { getTracingExporter, configureTracingEnvironment } from './tracingExporter';
import { configureMetricsEnvironment } from './metricsExporter';
import { setSDK } from './signozTelemetryUtils';
import { SemanticResourceAttributes } from '@opentelemetry/semantic-conventions';
import { registerInstrumentations } from '@opentelemetry/instrumentation';
import { OTLPTraceExporter } from '@opentelemetry/exporter-trace-otlp-proto';
import { OTLPMetricExporter } from '@opentelemetry/exporter-metrics-otlp-proto';
import { OTLPTraceExporter as OTLPTraceExporterHttp } from '@opentelemetry/exporter-trace-otlp-http';
import { OTLPMetricExporter as OTLPMetricExporterHttp } from '@opentelemetry/exporter-metrics-otlp-http';
import { PeriodicExportingMetricReader } from '@opentelemetry/sdk-metrics';
import { metrics } from '@opentelemetry/api';

// Define incubating semantic convention attributes
const ATTR_SERVICE_NAMESPACE = 'service.namespace';
const ATTR_DEPLOYMENT_ENVIRONMENT = 'deployment.environment';

// Logger configuration state
let loggerConfigured = false;

// Track if runtime is already installed
let isRuntimeInstalled = false;

export function getRuntimeEnvironment() {
  // Get environment information from process.env
  const environment = process.env.NODE_ENV || process.env.OTEL_ENVIRONMENT || 'development';
  
  // Basic attributes
  const attributes = {
    'service.namespace': process.env.TEMPORAL_NAMESPACE || 'default',
    'deployment.region': process.env.DEPLOYMENT_REGION || 'local',
    'host.name': process.env.HOSTNAME || 'localhost',
  };
  
  return {
    environment,
    attributes
  };
}

function configureLogger(logLevel: DiagLogLevel = DiagLogLevel.INFO): void {
    if (!loggerConfigured) {
        diag.setLogger(new DiagConsoleLogger(), logLevel);
        loggerConfigured = true;
        diag.info('[TELEMETRY] OpenTelemetry logger configured');
    }
}

function configureEnvironmentVariables(serviceName: string): void {
    // Configure core environment variables
    process.env.OTEL_SERVICE_NAME = serviceName;
    
    // Explicitly set OTLP exporter to avoid the "exporter not available" warning
    process.env.OTEL_TRACES_EXPORTER = 'otlp';
    process.env.OTEL_METRICS_EXPORTER = 'otlp';
    
    // Set default protocol if not specified
    if (!process.env.OTEL_EXPORTER_OTLP_PROTOCOL) {
        process.env.OTEL_EXPORTER_OTLP_PROTOCOL = 'grpc';
    }
    
    process.env.OTEL_PROPAGATORS = 'tracecontext,baggage';
    process.env.OTEL_LOGS_EXPORTER = 'none';
    
    // Configure tracing and metrics
    configureTracingEnvironment();
    configureMetricsEnvironment();
}

function createServiceResource(serviceName: string): Resource {
    const runtimeEnv = getRuntimeEnvironment();
    
    // Create a copy of attributes without service.namespace to avoid duplication
    const { 'service.namespace': _, ...otherAttributes } = runtimeEnv.attributes;
    
    return Resource.default().merge(
        new Resource({
            [ATTR_SERVICE_NAME]: serviceName,
            [ATTR_SERVICE_NAMESPACE]: runtimeEnv.attributes['service.namespace'],
            [ATTR_DEPLOYMENT_ENVIRONMENT]: runtimeEnv.environment,
            ...otherAttributes
        })
    );
}

export async function initOpenTelemetry(serviceName: string): Promise<void> {
    // Configure the OpenTelemetry logger
    configureLogger();
    
    // Configure environment variables
    configureEnvironmentVariables(serviceName);
    
    diag.info(`[TELEMETRY] Initializing OpenTelemetry for service: ${serviceName}`);
    
    const protocol = process.env.OTEL_EXPORTER_OTLP_PROTOCOL || 'grpc';
    const endpoint = process.env.OTEL_EXPORTER_OTLP_ENDPOINT || 'http://localhost:4317';
    
    diag.info(`[TELEMETRY] Configuring telemetry with ${protocol} protocol: ${endpoint}`);
    
    // Create instrumentation
    const instrumentations = getNodeAutoInstrumentations({
        '@opentelemetry/instrumentation-grpc': {
            ignoreGrpcMethods: []
        }
    });
    
    const traceExporter = getTracingExporter();
    
    // Create metrics reader with 5-second export interval (to match Java app)
    const metricsReader = getMetricsReader({ intervalMillis: 1000 });
    
    // Configure the SDK with explicit type casting to avoid linter errors due to library version mismatches
    const sdk = new NodeSDK({
        resource: createServiceResource(serviceName),
        traceExporter,
        instrumentations,
        spanProcessors: [],
        // @ts-ignore - Casting to avoid type errors between different OpenTelemetry package versions
        metricReader: metricsReader,
        textMapPropagator: new CompositePropagator({
            propagators: [
                new W3CTraceContextPropagator(),
                new W3CBaggagePropagator()
            ]
        })
    });
    
    // Store the SDK for later access
    setSDK(sdk);
    
    // Register SDK cleanup on process exit
    registerShutdownHandler(sdk);
    
    try {
        // Start the SDK
        await sdk.start();
        diag.info(`[TELEMETRY] OpenTelemetry SDK initialized successfully for ${serviceName}`);
    } catch (error) {
        diag.error(`[TELEMETRY] Failed to initialize OpenTelemetry SDK: ${error}`);
        throw error;
    }
    
    // Verify that metrics are enabled
    try {
        const meter = metrics.getMeter('verification');
        const counter = meter.createCounter('init_verification');
        counter.add(1, {
            'service.name': serviceName,
            'initialized': 'true'
        });
        diag.info('[TELEMETRY] Metrics recording verified successfully');
    } catch (error) {
        diag.warn(`[TELEMETRY] Failed to create verification metric: ${error}`);
    }
    
    // Install the OpenTelemetry SDK in Temporal Runtime
    try {
        await Runtime.install({
            telemetryOptions: {
                metrics: {
                    // @ts-ignore - The Temporal types may be out of date
                    enabled: true
                }
            }
        });
        diag.info('[TELEMETRY] Temporal Runtime installed with telemetry options');
    } catch (err) {
        diag.error(`[TELEMETRY] Failed to install Temporal Runtime with telemetry: ${err}`);
    }
}

function registerShutdownHandler(sdk: NodeSDK): void {
    // Only register for uncaught exceptions, let the worker handle SIGTERM/SIGINT
    // to prevent conflicts with multiple handlers
    
    // Handle uncaught errors
    process.on('uncaughtException', async (error) => {
        diag.error('[TELEMETRY] Uncaught exception, shutting down telemetry before exit:', error);
        
        try {
            const shutdownPromise = sdk.shutdown();
            const timeoutPromise = new Promise((_, reject) => 
                setTimeout(() => reject(new Error('Shutdown timed out')), 5000)
            );
            
            await Promise.race([shutdownPromise, timeoutPromise]);
            diag.info('[TELEMETRY] OpenTelemetry SDK shut down successfully');
        } catch (error) {
            diag.error('[TELEMETRY] Error shutting down OpenTelemetry SDK:', 
                error instanceof Error ? error.message : String(error));
        }
    });
}
```

### Step 5: Configure Temporal Telemetry Options & Dashboard Metrics
Create `temporalConfig.ts` to configure Temporal SDK clients, workers, and dashboard metrics using OpenTelemetry:

```
import { WorkerOptions } from '@temporalio/worker';
import { WorkflowClientOptions } from '@temporalio/client';
import * as WorkflowMetricsUtil from './workflowMetricsUtil';
import { diag } from '@opentelemetry/api';
import { OTLPMetricExporter } from '@opentelemetry/exporter-metrics-otlp-grpc';
import { PayloadConverter, ValueError, Payload } from '@temporalio/common';
import { getServiceName } from './signozTelemetryUtils';

// Add type declaration for globalThis
declare global {
  var __dashboardMetricsInterval: NodeJS.Timeout | undefined;
  var __dashboardMetricsInitialTimer: NodeJS.Timeout | undefined;
}

// ...

export const DEFAULT_TASK_QUEUE = 'hello-world';

export function configureTemporalEnvironment(options?: { 
    namespace?: string,
    serverUrl?: string 
}): void {
    // Set default or provided Temporal environment variables
    process.env.TEMPORAL_SERVER_URL = options?.serverUrl || 'localhost:7233';
    process.env.TEMPORAL_NAMESPACE = options?.namespace || 'default';
}

export function registerDashboardMetrics(options?: {
    initialDelayMs?: number,
    intervalMs?: number
}): () => void {
    const initialDelayMs = options?.initialDelayMs || 1000;
    const intervalMs = options?.intervalMs || 5000; // Match Java default (5000ms)
    
    diag.info(`[METRICS] Registering dashboard metrics with interval ${intervalMs}ms and initial delay ${initialDelayMs}ms`);
    console.log(`[METRICS] Registering dashboard metrics with interval ${intervalMs}ms and initial delay ${initialDelayMs}ms`);
    
    // Get service name from environment variables
    const serviceName = getServiceName('worker');
    
    // Record a service restart event
    WorkflowMetricsUtil.recordServiceRestart("worker");
    WorkflowMetricsUtil.recordSystemMetrics(serviceName);
    
    // Set initial timer
    const initialTimer = setTimeout(() => {
        // Send initial metrics
        diag.debug('[METRICS] Sending initial dashboard metrics');
        console.log('[METRICS] Sending initial dashboard metrics');
        
        // Generate sample workflow IDs and run IDs for metrics
        const workflowId = 'sample-workflow-id';
        const runId = 'sample-run-id';
        const namespace = 'default';
        
        // Emit initial metrics
        emitPeriodicMetrics(workflowId, runId, namespace);
        
        // Then set up interval
        const interval = setInterval(() => {
            diag.debug('[METRICS] Sending periodic dashboard metrics');
            console.log('[METRICS] Sending periodic dashboard metrics');
            emitPeriodicMetrics(workflowId, runId, namespace);
        }, intervalMs);
        
        // Store interval for cleanup
        globalThis.__dashboardMetricsInterval = interval;
    }, initialDelayMs);
    
    // Store the initial timer for cleanup
    globalThis.__dashboardMetricsInitialTimer = initialTimer;
    
    // Return a function to stop sending metrics
    return () => {
        diag.info('[METRICS] Dashboard metrics registration stopped');
        console.log('[METRICS] Dashboard metrics registration stopped');
        
        if (globalThis.__dashboardMetricsInitialTimer) {
            clearTimeout(globalThis.__dashboardMetricsInitialTimer);
            delete globalThis.__dashboardMetricsInitialTimer;
        }
        
        if (globalThis.__dashboardMetricsInterval) {
            clearInterval(globalThis.__dashboardMetricsInterval);
            delete globalThis.__dashboardMetricsInterval;
        }
    };
}

// ...

export function emitPeriodicMetrics(workflowId: string, runId: string, namespace: string): void {
    // Workflow types to emit metrics for
    const workflowTypes = [
        'HelloWorldWorkflow',
        // ... more workflow types.
    ];
    
    console.log(`[METRICS] Emitting metrics for workflow ID ${workflowId}, run ID ${runId}, namespace ${namespace}`);
    
    // Emit metrics for each workflow type
    workflowTypes.forEach(workflowType => {
        // Workflow state metrics
        WorkflowMetricsUtil.recordSuccess(workflowType, `${workflowId}-success`, runId, namespace);
        WorkflowMetricsUtil.recordFailure(workflowType, `${workflowId}-failure`, runId, namespace);
        // Record other workflow states like timeout, termination, cancellation etc.
        
        // Service request metrics
        WorkflowMetricsUtil.recordAddActivityTask();
        WorkflowMetricsUtil.recordRecordActivityTaskStarted();
        WorkflowMetricsUtil.recordResponseActivityCompleted();
        // ... and similar methods for other activity and workflow task metrics
        
        // Service error metrics
        WorkflowMetricsUtil.recordAddActivityTaskError();
        WorkflowMetricsUtil.recordRecordActivityTaskStartedError();
        WorkflowMetricsUtil.recordValidationError();
        // ... and similar methods for other error metrics
        
        // Timeout metrics
        WorkflowMetricsUtil.recordScheduleToStartWorkflowTimeout();
        WorkflowMetricsUtil.recordStartToCloseWorkflowTimeout();
    });
    
    // Service metrics
    WorkflowMetricsUtil.recordServiceRestart('worker');
    WorkflowMetricsUtil.recordServiceRestart('frontend');
    
}
```

### Step 6: Configure Workflow Client with Metrics

Create a client with OpenTelemetry metrics instrumentation:

```typescript:src/client.ts
import { Client } from '@temporalio/client';
import { initOpenTelemetry } from './config/opentelemetryConfig';
import { getMeter } from './config/signozTelemetryUtils';
import { registerDashboardMetrics } from './config/temporalConfig';
import { OpenTelemetryWorkflowClientInterceptor } from '@temporalio/interceptors-opentelemetry';
import * as WorkflowMetricsUtil from './config/workflowMetricsUtil';

async function run() {
  // 1. Configure metrics export settings
  process.env.OTEL_EXPORTER_OTLP_ENDPOINT = process.env.OTEL_EXPORTER_OTLP_ENDPOINT || 'http://localhost:4317';
  process.env.OTEL_METRICS_EXPORT_INTERVAL = '5000'; // 5-second export interval
  process.env.OTEL_METRICS_EXPORT_TIMEOUT = '4000'; // Shorter than interval

  // 2. Initialize OpenTelemetry metrics
  await initOpenTelemetry('temporal-hello-world-client');
  WorkflowMetricsUtil.initializeMetrics();
  const stopMetrics = registerDashboardMetrics(); // Start periodic metrics

  // 3. Create metric instruments
  const meter = getMeter();
  const workflowStartCounter = meter.createCounter('workflow_started_count_total', {
    description: 'Total workflow executions started'
  });
  
  const workflowCompletionCounter = meter.createCounter('workflow_completed_count_total', {
    description: 'Total workflow executions completed'
  });

  // 4. Configure client with metrics interceptor
  const client = new Client({
    ... // connection config
    interceptors: {
      workflow: [new OpenTelemetryWorkflowClientInterceptor()] // Metrics collection
    }
  });

  try {
    // 5. Record workflow start metric
    workflowStartCounter.add(1, { 'workflow_type': 'HelloWorld' });
    WorkflowMetricsUtil.recordServiceRequest('StartWorkflow');

    ... // Workflow execution logic

    // 6. Record success metrics
    workflowCompletionCounter.add(1, { 'workflow_type': 'HelloWorld' });
    WorkflowMetricsUtil.recordSuccess(...);
    
  } catch (error) {
    // 7. Record failure metrics
    workflowCompletionCounter.add(1);
    WorkflowMetricsUtil.recordFailure(...);
    ...
  } finally {
    // 8. Cleanup metrics resources
    stopMetrics();
    await new Promise(resolve => setTimeout(resolve, 5000)); // Final export
    WorkflowMetricsUtil.cleanup();
  }
}

run().catch(err => {
  console.error('Fatal error:', err);
  process.exit(1);
});
```

### Step 7: Configure Environment Variables

```bash
# SigNoz endpoint
OTEL_EXPORTER_OTLP_ENDPOINT=http://localhost:4317

# Set service name and other attributes
OTEL_RESOURCE_ATTRIBUTES="service.name=temporal-hello-world"
```

### Step 8: Run Application

1. Start the worker:
```bash
npm run worker
```

2. Execute a workflow to generate metrics:
```bash
npm run workflow
```

</TabItem>

<TabItem value="go" label="Go">

### Step 1: Add OpenTelemetry Dependencies

Add the following dependencies to your `go.mod`:

```go
require (
	go.opentelemetry.io/otel v1.24.0
	go.opentelemetry.io/otel/exporters/otlp/otlpmetric/otlpmetricgrpc v1.24.0
	go.opentelemetry.io/otel/exporters/otlp/otlptrace v1.24.0
	go.opentelemetry.io/otel/exporters/otlp/otlptrace/otlptracegrpc v1.24.0
	go.opentelemetry.io/otel/metric v1.24.0
	go.opentelemetry.io/otel/sdk v1.24.0
	go.opentelemetry.io/otel/sdk/metric v1.24.0
	go.opentelemetry.io/otel/trace v1.24.0
	go.opentelemetry.io/proto/otlp v1.1.0
	go.temporal.io/api v1.24.0
	go.temporal.io/sdk v1.25.1
	go.temporal.io/sdk/contrib/opentelemetry v0.3.0
	google.golang.org/grpc v1.61.1
)
```

### Step 2: Configure OpenTelemetry

Create `signoz_telemetry_utils.go` to coordinate the OpenTelemetry components:

```go:internal/helloworld/config/signoz_telemetry_utils.go
package config

import (
	"context"
	"fmt"
	"log"
	"time"

	"go.opentelemetry.io/otel"
)

// SignozTelemetryUtils coordinates all telemetry components
type SignozTelemetryUtils struct {
	otelConfig *OpenTelemetryConfig
}

// NewSignozTelemetryUtils creates a new telemetry configuration
func NewSignozTelemetryUtils() *SignozTelemetryUtils {
	return &SignozTelemetryUtils{
		otelConfig: NewOpenTelemetryConfig(),
	}
}

// InitProvider initializes all telemetry providers
func (c *SignozTelemetryUtils) InitProvider(ctx context.Context) (func(), error) {
	// Create resource
	res, err := c.otelConfig.CreateResource(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed to create resource: %w", err)
	}

	// Get TLS credentials
	creds := c.otelConfig.GetTLSCredentials()

	// Initialize metrics
	metricsConfig := &MetricsExporterConfig{
		ServiceName: c.otelConfig.ServiceName,
		Environment: c.otelConfig.Environment,
		Endpoint:    c.otelConfig.Endpoint,
		Headers:     c.otelConfig.Headers,
		TLSCreds:    creds,
	}
	meterProvider, err := NewMetricsExporter(ctx, metricsConfig, res)
	if err != nil {
		return nil, fmt.Errorf("failed to create metrics exporter: %w", err)
	}

	// Set global meter provider
	otel.SetMeterProvider(meterProvider)

	// Initialize tracing
	tracingConfig := &TracingExporterConfig{
		ServiceName: c.otelConfig.ServiceName,
		Environment: c.otelConfig.Environment,
		Endpoint:    c.otelConfig.Endpoint,
		Headers:     c.otelConfig.Headers,
		TLSCreds:    creds,
	}
	tracerProvider, err := NewTracingExporter(ctx, tracingConfig, res)
	if err != nil {
		return nil, fmt.Errorf("failed to create tracer provider: %w", err)
	}

	// Set global tracer provider
	otel.SetTracerProvider(tracerProvider)

	// Setup propagator
	SetupPropagator()

	// Return cleanup function
	cleanup := func() {
		shutdownCtx, cancel := context.WithTimeout(context.Background(), 30*time.Second)
		defer cancel()

		if err := tracerProvider.Shutdown(shutdownCtx); err != nil {
			log.Printf("[ERROR] Error shutting down tracer provider: %v\n", err)
		}

		if err := meterProvider.Shutdown(shutdownCtx); err != nil {
			log.Printf("[ERROR] Error shutting down meter provider: %v\n", err)
		}
	}

	return cleanup, nil
}
```

### Step 3: Configure OpenTelemetry Settings

Create `opentelemetry_config.go` to manage OpenTelemetry configuration:

```go:internal/helloworld/config/opentelemetry_config.go
package config

import (
	"context"
	"fmt"
	"os"
	"strings"

	"go.opentelemetry.io/otel"
	"go.opentelemetry.io/otel/propagation"
	"go.opentelemetry.io/otel/sdk/resource"
	semconv "go.opentelemetry.io/otel/semconv/v1.24.0"
	"google.golang.org/grpc/credentials"
	"google.golang.org/grpc/credentials/insecure"
)

// OpenTelemetryConfig holds OpenTelemetry configuration
type OpenTelemetryConfig struct {
	ServiceName string
	Environment string
	Endpoint    string
	Headers     map[string]string
	UseTLS      bool
}

// NewOpenTelemetryConfig creates a new OpenTelemetry configuration
func NewOpenTelemetryConfig() *OpenTelemetryConfig {
	endpoint := os.Getenv("OTEL_EXPORTER_OTLP_ENDPOINT")
	useTLS := false

	if endpoint == "" {
		endpoint = "localhost:4317"
	} else {
		// Check if this is a cloud endpoint that needs TLS
		if strings.Contains(endpoint, "https://") || strings.Contains(endpoint, "signoz.cloud") {
			useTLS = true
			// For gRPC, we don't need the https:// prefix
			endpoint = strings.TrimPrefix(strings.TrimPrefix(endpoint, "https://"), "http://")
		} else {
			// For non-TLS endpoint
			endpoint = strings.TrimPrefix(strings.TrimPrefix(endpoint, "http://"), "https://")
		}
	}

	// Debug output
	headers := parseHeaders()
	fmt.Printf("[DEBUG] OTEL endpoint: %s\n", endpoint)
	fmt.Printf("[DEBUG] OTEL headers: %v\n", headers)
	fmt.Printf("[DEBUG] OTEL using TLS: %v\n", useTLS)

	return &OpenTelemetryConfig{
		ServiceName: "temporal-hello-world",
		Environment: "development",
		Endpoint:    endpoint,
		Headers:     headers,
		UseTLS:      useTLS,
	}
}

// CreateResource creates a new resource with common attributes
func (c *OpenTelemetryConfig) CreateResource(ctx context.Context) (*resource.Resource, error) {
	hostname, _ := os.Hostname()
	return resource.New(ctx,
		resource.WithAttributes(
			semconv.ServiceName(c.ServiceName),
			semconv.ServiceVersion("1.0.0"),
			semconv.DeploymentEnvironment(c.Environment),
			semconv.HostName(hostname),
			semconv.ServiceInstanceID(fmt.Sprintf("%s-%d", hostname, os.Getpid())),
		),
		resource.WithSchemaURL(semconv.SchemaURL),
	)
}

// GetTLSCredentials returns the appropriate TLS credentials
func (c *OpenTelemetryConfig) GetTLSCredentials() credentials.TransportCredentials {
	fmt.Printf("[DEBUG] Getting TLS credentials, UseTLS: %v\n", c.UseTLS)
	if c.UseTLS {
		return credentials.NewClientTLSFromCert(nil, "")
	}
	return insecure.NewCredentials()
}

// SetupPropagator configures the global propagator
func SetupPropagator() {
	otel.SetTextMapPropagator(propagation.NewCompositeTextMapPropagator(
		propagation.TraceContext{},
		propagation.Baggage{},
	))
}

// GetSpanAttributes returns a map of common attributes for spans
func GetSpanAttributes(workflowType, workflowID, taskQueue string) map[string]string {
	attrs := make(map[string]string)
	attrs["workflow_type"] = workflowType
	attrs["workflow_id"] = workflowID
	attrs["task_queue"] = taskQueue
	attrs["namespace"] = "default" // Default namespace, can be overridden if needed
	return attrs
}

// parseHeaders parses OTEL_EXPORTER_OTLP_HEADERS environment variable
func parseHeaders() map[string]string {
	headers := make(map[string]string)
	headerStr := os.Getenv("OTEL_EXPORTER_OTLP_HEADERS")
	if headerStr != "" {
		// Parse headers in format "key1=value1,key2=value2"
		pairs := strings.Split(headerStr, ",")
		for _, pair := range pairs {
			kv := strings.SplitN(pair, "=", 2)
			if len(kv) == 2 {
				headers[strings.TrimSpace(kv[0])] = strings.TrimSpace(kv[1])
			}
		}
	}
	return headers
}
```

### Step 4: Set Up Metrics Export

Create `metrics_exporter.go` to configure the OTLP trace exporter:

```go:internal/helloworld/config/metrics_exporter.go
package config

import (
	"context"
	"fmt"
	"time"

	"go.opentelemetry.io/otel/attribute"
	"go.opentelemetry.io/otel/exporters/otlp/otlpmetric/otlpmetricgrpc"
	"go.opentelemetry.io/otel/metric"
	sdkmetric "go.opentelemetry.io/otel/sdk/metric"
	"go.opentelemetry.io/otel/sdk/resource"
	"google.golang.org/grpc/credentials"
)

// MetricsExporterConfig holds configuration for metrics export
type MetricsExporterConfig struct {
	ServiceName string
	Environment string
	Endpoint    string
	Headers     map[string]string
	TLSCreds    credentials.TransportCredentials
}

// NewMetricsExporter creates and configures the metrics exporter
func NewMetricsExporter(ctx context.Context, cfg *MetricsExporterConfig, res *resource.Resource) (*sdkmetric.MeterProvider, error) {
	// Configure metrics exporter
	exporter, err := otlpmetricgrpc.New(ctx,
		otlpmetricgrpc.WithEndpoint(cfg.Endpoint),
		otlpmetricgrpc.WithHeaders(cfg.Headers),
		otlpmetricgrpc.WithTLSCredentials(cfg.TLSCreds),
		otlpmetricgrpc.WithRetry(otlpmetricgrpc.RetryConfig{
			Enabled:         true,
			InitialInterval: 1 * time.Second,
			MaxInterval:     5 * time.Second,
			MaxElapsedTime:  30 * time.Second,
		}),
	)
	if err != nil {
		return nil, fmt.Errorf("failed to create metrics exporter: %w", err)
	}

	// Configure periodic reader with more frequent reporting
	reader := sdkmetric.NewPeriodicReader(
		exporter,
		sdkmetric.WithInterval(1*time.Second),
	)

	// Create meter provider
	mp := sdkmetric.NewMeterProvider(
		sdkmetric.WithResource(res),
		sdkmetric.WithReader(reader),
	)

	// Register common metrics
	meter := mp.Meter("temporal-hello-world")
	if err := RegisterCommonMetrics(meter); err != nil {
		return nil, fmt.Errorf("failed to register common metrics: %w", err)
	}

	return mp, nil
}

// RegisterCommonMetrics registers metrics that are common across the application
func RegisterCommonMetrics(meter metric.Meter, attrs ...attribute.KeyValue) error {
	// Initialize all workflow metrics using our WorkflowMetricsUtil equivalent
	return InitializeMetrics(meter)
}
```

### Step 5: Configure  Dashboard Metrics
Create `workflow_metrics_util.go` to configure Temporal SDK clients, workers, and dashboard metrics using OpenTelemetry:

```go:internal/helloworld/config/workflow_metrics_util.go
package config

import (
	"context"
	"log"
	"sync"

	"go.opentelemetry.io/otel"
	"go.opentelemetry.io/otel/attribute"
	"go.opentelemetry.io/otel/metric"
)

var (
	// Metric counters
	workflowSuccess metric.Int64Counter
	workflowFailed  metric.Int64Counter
	// ... other metric variables

	// Common attributes
	WorkflowTypeKey = attribute.Key("workflow_type")
	WorkflowIDKey   = attribute.Key("workflow_id")
	RunIDKey        = attribute.Key("run_id")
	NamespaceKey    = attribute.Key("namespace")
	OperationKey    = attribute.Key("operation")
	// ... other attribute keys

	once sync.Once
)

// Helper to create a counter with common options
func createCounter(meter metric.Meter, name, desc, unit string) (metric.Int64Counter, error) {
	return meter.Int64Counter(
		name,
		metric.WithDescription(desc),
		metric.WithUnit(unit),
	)
}

// InitializeMetrics registers workflow and service metrics
func InitializeMetrics(meter metric.Meter) error {
	var err error

	workflowSuccess, err = createCounter(meter, "workflow_success", "Count of successfully completed workflows", "{execution}")
	if err != nil {
		return err
	}

	workflowFailed, err = createCounter(meter, "workflow_failed", "Count of failed workflows", "{execution}")
	if err != nil {
		return err
	}

	// ... initialize other metrics similarly

	return nil
}

// Ensures metrics are initialized only once
func ensureMetricsInitialized() {
	once.Do(func() {
		log.Println("Initializing metrics counters...")
		meter := otel.GetMeterProvider().Meter("temporal-metrics")
		if err := InitializeMetrics(meter); err != nil {
			log.Printf("Failed to initialize metrics: %v", err)
		} else {
			log.Println("Metrics counters initialized successfully")
		}
	})
}

// Helper to record metrics with common attributes
func recordCounter(ctx context.Context, counter metric.Int64Counter, attrs ...attribute.KeyValue) {
	ensureMetricsInitialized()
	counter.Add(ctx, 1, metric.WithAttributes(attrs...))
}

// Example usage: record workflow success
func RecordSuccess(ctx context.Context, workflowType, workflowID, runID, namespace string) {
	recordCounter(ctx, workflowSuccess,
		WorkflowTypeKey.String(workflowType),
		WorkflowIDKey.String(workflowID),
		RunIDKey.String(runID),
		NamespaceKey.String(namespace),
		OperationKey.String("CompletionStats"),
	)
}

// ...
```

### Step 6: Configure Main Application with OpenTelemetry

```go:cmd/helloworld/main.go
package main

import (
	"context"
	"log"
	"os"
	"os/signal"
	"syscall"
	"time"

	"github.com/creator54/temporal-go-demo-app/internal/helloworld/config"
	"go.opentelemetry.io/otel"
)

func main() {
	// 1. Context and signal handling setup (essential for clean shutdown)
	ctx, cancel := context.WithCancel(context.Background())
	defer cancel()

	sigChan := make(chan os.Signal, 1)
	signal.Notify(sigChan, os.Interrupt, syscall.SIGTERM)
	go func() {
		sig := <-sigChan
		log.Printf("METRICS: Received %v - initiating shutdown", sig)
		cancel()
	}()

	// 2. OpenTelemetry metrics initialization
	log.SetFlags(log.LstdFlags | log.Lmicroseconds)
	log.Println("METRICS: Initializing OpenTelemetry...")

	telemetry := config.NewSignozTelemetryUtils()
	cleanup, err := telemetry.InitProvider(ctx)
	if err != nil {
		log.Fatalf("METRICS: Failed to initialize - %v", err)
	}
	defer func() {
		log.Println("METRICS: Flushing remaining metrics...")
		cleanup()
	}()

	// 3. Metrics instrumentation setup
	log.Println("METRICS: Creating metric instruments...")
	meter := otel.GetMeterProvider().Meter("temporal-metrics")
	if err := config.InitializeMetrics(meter); err != nil {
		log.Fatalf("METRICS: Instrumentation failed - %v", err)
	}

	// ... (Temporal worker/workflow setup would go here)
	
	// 4. Maintain context until shutdown
	<-ctx.Done()
	log.Println("METRICS: Final export buffer...")
	time.Sleep(2 * time.Second) // Allow final metric exports
}
```

### Step 7: Configure Environment Variables

```bash
# SigNoz endpoint
export OTEL_EXPORTER_OTLP_ENDPOINT="http://localhost:4317"

# Set service name and other attributes
OTEL_RESOURCE_ATTRIBUTES="service.name=temporal-hello-world"
```

### Step 8: Run Application

1. Start the worker:
```bash
go run ./cmd/helloworld -worker
```

2. Execute a workflow to generate metrics:
```bash
go run ./cmd/helloworld
```

</TabItem>
</Tabs>
</TabItem>

<TabItem value="signoz-cloud" label="SigNoz Cloud">
<Tabs>
<TabItem value="java" label="Java" default>

### Step 1: Add OpenTelemetry Dependencies

Add to your `pom.xml`:

```xml
<properties>
    <opentelemetry.version>1.34.1</opentelemetry.version>
    <temporal.version>1.24.1</temporal.version>
</properties>

<dependencies>
    <!-- Temporal -->
    <dependency>
        <groupId>io.temporal</groupId>
        <artifactId>temporal-sdk</artifactId>
        <version>${temporal.version}</version>
    </dependency>
    <dependency>
        <groupId>io.temporal</groupId>
        <artifactId>temporal-opentracing</artifactId>
        <version>${temporal.version}</version>
    </dependency>

    <!-- OpenTelemetry -->
    <dependency>
        <groupId>io.opentelemetry</groupId>
        <artifactId>opentelemetry-api</artifactId>
        <version>${opentelemetry.version}</version>
    </dependency>
    <dependency>
        <groupId>io.opentelemetry</groupId>
        <artifactId>opentelemetry-sdk</artifactId>
        <version>${opentelemetry.version}</version>
    </dependency>
    <dependency>
        <groupId>io.opentelemetry</groupId>
        <artifactId>opentelemetry-exporter-otlp</artifactId>
        <version>${opentelemetry.version}</version>
    </dependency>
    <dependency>
        <groupId>io.opentelemetry</groupId>
        <artifactId>opentelemetry-extension-trace-propagators</artifactId>
        <version>${opentelemetry.version}</version>
    </dependency>
</dependencies>
```

### Step 2: Configure OpenTelemetry

Create `SignozTelemetryUtils.java` to configure OpenTelemetry with SigNoz OTLP exporter, trace propagation, and Temporal interceptors:

```java:src/main/java/helloworld/config/SignozTelemetryUtils.java
```java:src/main/java/helloworld/config/SignozTelemetryUtils.java
package helloworld.config;

import com.uber.m3.tally.Scope;
import io.opentelemetry.api.OpenTelemetry;
import io.opentelemetry.api.metrics.Meter;
import io.opentelemetry.api.trace.Tracer;
import io.opentelemetry.context.propagation.ContextPropagators;
import io.opentelemetry.api.trace.propagation.W3CTraceContextPropagator;
import io.opentelemetry.sdk.OpenTelemetrySdk;
import io.opentelemetry.sdk.resources.Resource;
import io.temporal.common.interceptors.WorkerInterceptor;
import java.util.logging.Level;
import java.util.logging.Logger;

public class SignozTelemetryUtils {
    private static final Logger logger = Logger.getLogger(SignozTelemetryUtils.class.getName());
    private static volatile boolean initialized = false;
    private static Meter meter;
    private static Tracer tracer;
    
    public static synchronized void initializeTelemetry() {
        if (initialized) {
            return;
        }
        
        logger.info("Initializing OpenTelemetry...");
        
        try {
            // Create resource with service info
            Resource resource = OpenTelemetryConfig.createResource();
            
            // Build SDK with metrics and tracing support
            OpenTelemetrySdk sdk = OpenTelemetrySdk.builder()
                .setTracerProvider(TracingExporter.createTracerProvider())
                .setMeterProvider(MetricsExporter.createMeterProvider())
                .setPropagators(ContextPropagators.create(W3CTraceContextPropagator.getInstance()))
                .build();
            
            OpenTelemetryConfig.setOpenTelemetry(sdk);
            
            // Initialize meters and tracers
            meter = sdk.getMeter("io.temporal");
            tracer = sdk.getTracer("io.temporal");
            
            // Initialize workflow metrics for the dashboard
            WorkflowMetricsUtil.initializeMetrics();
            
            // Add shutdown hook for clean telemetry shutdown
            Runtime.getRuntime().addShutdownHook(new Thread(() -> {
                logger.info("Shutting down OpenTelemetry...");
                
                // First, clean up WorkflowMetricsUtil resources
                WorkflowMetricsUtil.cleanup();
                
                // Force metrics export before shutdown
                try {
                    // Allow time for any pending metrics to be exported
                    Thread.sleep(500);
                } catch (InterruptedException e) {
                    logger.log(Level.WARNING, "Interrupted during shutdown delay", e);
                }
                
                // Shutdown exporters
                TracingExporter.shutdown();
                MetricsExporter.shutdown();
                
                // Reset local references
                meter = null;
                tracer = null;
                initialized = false;
            }));
            
            initialized = true;
            logger.info("OpenTelemetry initialization complete");
        } catch (Exception e) {
            logger.log(Level.SEVERE, "Error initializing OpenTelemetry", e);
        }
    }
    
    public static Meter getMeter() {
        if (!initialized) {
            logger.warning("OpenTelemetry not initialized. Call initializeTelemetry() first.");
        }
        return meter;
    }
    
    public static Tracer getTracer() {
        if (!initialized) {
            logger.warning("OpenTelemetry not initialized. Call initializeTelemetry() first.");
        }
        return tracer;
    }
    
    public static Scope getMetricsScope() {
        return MetricsExporter.getMetricsScope();
    }

    public static WorkerInterceptor getWorkerInterceptor() {
        return TracingExporter.getWorkerInterceptor();
    }
    
    private SignozTelemetryUtils() {
        // Prevent instantiation - use static methods
    }
}
```

### Step 3: Configure OpenTelemetry Settings

Create `OpenTelemetryConfig.java` to manage OpenTelemetry configuration including service attributes, resource settings, and endpoint configuration. This class will be used by the telemetry utilities to initialize the OpenTelemetry SDK.

```java:src/main/java/helloworld/config/OpenTelemetryConfig.java
```java:src/main/java/helloworld/config/OpenTelemetryConfig.java
package helloworld.config;

import io.opentelemetry.api.OpenTelemetry;
import io.opentelemetry.api.common.Attributes;
import io.opentelemetry.api.common.AttributeKey;
import io.opentelemetry.api.trace.propagation.W3CTraceContextPropagator;
import io.opentelemetry.context.propagation.ContextPropagators;
import io.opentelemetry.sdk.OpenTelemetrySdk;
import io.opentelemetry.sdk.resources.Resource;
import io.temporal.client.WorkflowClient;
import io.temporal.serviceclient.WorkflowServiceStubs;
import java.util.logging.Level;
import java.util.logging.Logger;
import java.util.HashMap;
import java.util.Map;

public final class OpenTelemetryConfig {
    private static final Logger logger = Logger.getLogger(OpenTelemetryConfig.class.getName());

    // Default values used when environment variables are not set
    public static final String DEFAULT_SIGNOZ_ENDPOINT = "http://localhost:4317";

    //OpenTelemetry resource attribute keys for custom attribute creation
    public static final AttributeKey<String> SERVICE_NAME = AttributeKey.stringKey("service.name");
    public static final AttributeKey<String> ACCESS_TOKEN = AttributeKey.stringKey("signoz-access-token");
    public static final AttributeKey<String> SERVICE_NAMESPACE = AttributeKey.stringKey("service.namespace");
    public static final AttributeKey<String> DEPLOYMENT_ENVIRONMENT = AttributeKey.stringKey("deployment.environment");

    // Environment variables for configuration override
    private static final String ENV_OTEL_ENDPOINT = "OTEL_EXPORTER_OTLP_ENDPOINT";  // Collector endpoint
    private static final String ENV_ENVIRONMENT = "OTEL_ENVIRONMENT";               // Deployment environment
    private static final String ENV_RESOURCE_ATTRIBUTES = "OTEL_RESOURCE_ATTRIBUTES"; // Resource attributes
    private static final String ENV_SIGNOZ_ACCESS_TOKEN = "OTEL_EXPORTER_OTLP_HEADERS"; // SigNoz access token

    // Global SDK instance - initialized by SignozTelemetryUtils
    private static volatile OpenTelemetry openTelemetry;
    private static WorkflowServiceStubs service;
    private static WorkflowClient client;
    private static volatile Resource resource;

    public static OpenTelemetry getOpenTelemetry() {
        if (openTelemetry == null) {
            throw new IllegalStateException("OpenTelemetry not initialized. Call initialize() first.");
        }
        return openTelemetry;
    }


    public static Resource createResource() {
        if (resource != null) {
            return resource;
        }

        synchronized (OpenTelemetryConfig.class) {
            if (resource != null) {
                return resource;
            }

            String environment = System.getenv().getOrDefault(ENV_ENVIRONMENT, "development");
            
            // Parse OTEL_RESOURCE_ATTRIBUTES
            String resourceAttrs = System.getenv(ENV_RESOURCE_ATTRIBUTES);
            Map<AttributeKey<String>, String> attributes = new HashMap<>();
            
            if (resourceAttrs != null) {
                // Parse comma-separated key-value pairs
                for (String pair : resourceAttrs.split(",")) {
                    String[] keyValue = pair.trim().split("=", 2);
                    if (keyValue.length == 2) {
                        String key = keyValue[0].trim();
                        String value = keyValue[1].trim();
                        if ("service.name".equals(key)) {
                            attributes.put(SERVICE_NAME, value);
                        }
                    }
                }
            }

            // Verify service.name is set
            if (!attributes.containsKey(SERVICE_NAME)) {
                throw new IllegalStateException(
                    "service.name must be configured via OTEL_RESOURCE_ATTRIBUTES environment variable. " +
                    "Example: OTEL_RESOURCE_ATTRIBUTES=service.name=your-service-name"
                );
            }

            // Create resource with attributes
            resource = Resource.create(
                Attributes.of(
                    SERVICE_NAME, attributes.get(SERVICE_NAME),
                    SERVICE_NAMESPACE, "default",
                    DEPLOYMENT_ENVIRONMENT, environment
                )
            );
            
            logger.info("Creating resource with service.name: " + attributes.get(SERVICE_NAME));
            logger.info("Environment: " + environment);
            logger.info("Resource attributes: " + resourceAttrs);
            
            return Resource.getDefault().merge(resource);
        }
    }

    public static String getEndpoint() {
        String endpoint = System.getenv().getOrDefault(ENV_OTEL_ENDPOINT, DEFAULT_SIGNOZ_ENDPOINT);
        
        // Ensure the endpoint starts with a protocol
        if (!endpoint.startsWith("http://") && !endpoint.startsWith("https://")) {
            endpoint = "http://" + endpoint;
        }
        
        return endpoint;
    }

    public static String getAccessToken() {
        return System.getenv().get(ENV_SIGNOZ_ACCESS_TOKEN);
    }

    public static String getResourceAttributes() {
        return System.getenv().get(ENV_RESOURCE_ATTRIBUTES);
    }

    public static String getServiceName() {
        String resourceAttrs[] = System.getenv(ENV_RESOURCE_ATTRIBUTES).split(",");
        for (String pair : resourceAttrs) {
            String[] keyValue = pair.trim().split("=", 2);
            if ("service.name".equals(keyValue[0].trim())) {
                return keyValue[1].trim();
            }
        }
        return "temporal-hello-world";
    }

    protected static synchronized void setOpenTelemetry(OpenTelemetrySdk sdk) {
        if (openTelemetry != null) {
            throw new IllegalStateException("OpenTelemetry already initialized");
        }
        openTelemetry = sdk;
    }

    private OpenTelemetryConfig() {
        // Prevent instantiation - use static methods
    }
}
```

### Step 4: Set Up Metrics Export

Create `MetricsExporter.java` to configure metrics export to SigNoz with OTLP/gRPC, batch processing, and Temporal metrics:

```java:src/main/java/helloworld/config/MetricsExporter.java
package helloworld.config;

import io.opentelemetry.exporter.otlp.metrics.OtlpGrpcMetricExporter;
import io.opentelemetry.sdk.metrics.SdkMeterProvider;
import io.opentelemetry.sdk.metrics.export.PeriodicMetricReader;
import io.opentelemetry.sdk.metrics.InstrumentSelector;
import io.opentelemetry.sdk.metrics.View;
import com.uber.m3.tally.NoopScope;
import com.uber.m3.tally.Scope;
import java.util.logging.Logger;
import java.util.concurrent.TimeUnit;

public class MetricsExporter {
    private static final Logger logger = Logger.getLogger(MetricsExporter.class.getName());
    private static Scope metricsScope;
    private static PeriodicMetricReader metricReader;

    public static synchronized Scope getMetricsScope() {
        if (metricsScope == null) {
            metricsScope = new NoopScope();
        }
        return metricsScope;
    }

    public static SdkMeterProvider createMeterProvider() {
        String endpoint = OpenTelemetryConfig.getEndpoint();
        String accessToken = OpenTelemetryConfig.getAccessToken();
        
        // Parse the header key and value
        String headerKey = null;
        String headerValue = accessToken;
        if (accessToken != null && accessToken.contains("=")) {
            String[] parts = accessToken.split("=", 2);
            headerKey = parts[0];
            headerValue = parts[1];
        }

        // Create OTLP metric exporter
        OtlpGrpcMetricExporter metricExporter;
        if (headerKey != null && headerValue != null && !headerValue.isEmpty()) {
            logger.info("Metrics header key: " + headerKey);
            logger.info("Metrics endpoint: " + endpoint);
            metricExporter = OtlpGrpcMetricExporter.builder()
                .setEndpoint(endpoint)
                .addHeader(headerKey, headerValue)
                .setTimeout(java.time.Duration.ofSeconds(60))
                .build();
        } else {
            metricExporter = OtlpGrpcMetricExporter.builder()
                .setEndpoint(endpoint)
                .setTimeout(java.time.Duration.ofSeconds(60))
                .build();
        }

        // Create metric reader with optimized settings
        metricReader = PeriodicMetricReader.builder(metricExporter)
            .setInterval(java.time.Duration.ofSeconds(1))  // More frequent updates for better visibility
            .build();

        // Create views for workflow metrics
        View workflowStartedView = View.builder()
            .setName("workflow_started_count_total")
            .setDescription("Total number of workflow executions started")
            .setAggregation(io.opentelemetry.sdk.metrics.Aggregation.sum())
            .build();

        View workflowCompletedView = View.builder()
            .setName("workflow_completed_count_total")
            .setDescription("Total number of workflow executions completed")
            .setAggregation(io.opentelemetry.sdk.metrics.Aggregation.sum())
            .build();

        // Create and return meter provider with views
        return SdkMeterProvider.builder()
            .setResource(OpenTelemetryConfig.createResource())
            .registerMetricReader(metricReader)
            .registerView(
                InstrumentSelector.builder()
                    .setName("workflow_started_count_total")
                    .build(),
                workflowStartedView)
            .registerView(
                InstrumentSelector.builder()
                    .setName("workflow_completed_count_total")
                    .build(),
                workflowCompletedView)
            .build();
    }

    public static void shutdown() {
        if (metricReader != null) {
            try {
                logger.info("Shutting down metrics reader...");
                
                // First flush any pending metrics
                try {
                    metricReader.forceFlush().join(10, TimeUnit.SECONDS);
                    logger.info("Metrics flush completed");
                } catch (Exception e) {
                    logger.warning("Metrics flush failed: " + e.getMessage());
                }
                
                // Then shutdown the reader
                try {
                    metricReader.shutdown().join(10, TimeUnit.SECONDS);
                    logger.info("Metrics reader shutdown completed successfully");
                } catch (Exception e) {
                    logger.warning("Metrics reader shutdown failed: " + e.getMessage());
                }
            } catch (Exception e) {
                logger.severe("Error during metrics reader shutdown: " + e.getMessage());
            } finally {
                metricReader = null;
                metricsScope = null;
            }
        }
    }

    private MetricsExporter() {
        // Prevent instantiation - use static methods
    }
}
```

### Step 5: Configure Worker with Metrics

Configure your Temporal Worker to initialize and integrate OpenTelemetry metrics collection:

```java:src/main/java/helloworld/workers/HelloWorldWorker.java
public class HelloWorldWorker implements AutoCloseable {
    ...

    public HelloWorldWorker() {
        // Initialize OpenTelemetry SDK for metrics collection
        SignozTelemetryUtils.initializeTelemetry();

        // Configure Temporal client to expose metrics through OpenTelemetry
        WorkflowServiceStubsOptions stubOptions = WorkflowServiceStubsOptions.newBuilder()
            .setMetricsScope(SignozTelemetryUtils.getMetricsScope()) // Get OTEL metrics context
            .build();

        // Enable workflow-level metric tracking via interceptor
        WorkerFactoryOptions factoryOptions = WorkerFactoryOptions.newBuilder()
            .setWorkerInterceptors(SignozTelemetryUtils.getWorkerInterceptor()) // Metrics collection hook
            .build();

        ... //Temporal worker initialization
    }

    public void start() {
        try {
            ... // worker startup
            
            // Register custom metric definitions (counter/gauges/histograms)
            TemporalConfig.registerDashboardMetrics();
            
            ... //shutdown hook setup
        } catch (Exception e) {
            ... // Error handling
        }
    }

    @Override
    public void close() {
        ... // Temporal shutdown logic
        
        try {            
            // Release metric resources before shutdown
            helloworld.config.WorkflowMetricsUtil.cleanup();
            
            // Flush remaining metric data to exporter
            SignozTelemetryUtils.getMetricsScope().close();
            
            // Allow buffer time for final metric exports
            Thread.sleep(1000);
            
            // Shutdown metrics export pipeline
            MetricsExporter.shutdown();

            ... // Remaining cleanup
        } catch (Exception e) {
            ... // Error handling
        }
    }
}
```

### Step 6: Configure Workflow Starter
Update your Temporal Workflow Starter to initialize OpenTelemetry for metrics:

```java:src/main/java/helloworld/main/HelloWorldStarter.java
public class HelloWorldStarter {
    ...

    public HelloWorldStarter() {
        // 1. Initialize OpenTelemetry metrics collection
        SignozTelemetryUtils.initializeTelemetry();

        // 2. Create metrics instruments
        Meter meter = SignozTelemetryUtils.getMeter();
        workflowCompletionCounter = meter
            .counterBuilder("workflow_completed_count_total")
            .setDescription("Tracks total completed workflows")
            .build();
            
        workflowStartCounter = meter
            .counterBuilder("workflow_started_count_total")
            .setDescription("Tracks total initiated workflows")
            .build();

        // 3. Attach metrics collection to Temporal client
        WorkflowServiceStubsOptions stubOptions = WorkflowServiceStubsOptions.newBuilder()
            .setMetricsScope(SignozTelemetryUtils.getMetricsScope()) // Connect OTEL metrics
            .build();

        ... //client setup
    }

    public void runWorkflow(String name) {
        ... //workflow setup
        
        try {
            // 4. Record workflow initiation metric
            workflowStartCounter.add(1L);
            
            ... // Workflow execution logic
            
            // 5. Record successful completion metric
            workflowCompletionCounter.add(1L);
            WorkflowMetricsUtil.recordSuccess(...);
            
        } catch (Exception e) {
            // 6. Record failure metric
            WorkflowMetricsUtil.recordFailure(...);
            ...
        } finally {
            // 7. Ensure metrics export cleanup
            MetricsExporter.shutdown();
            Thread.sleep(1000); // Allow final metric flush
            ...
        }
    }

    ... // Main method
}
```

### Step 7: Configure Environment Variables for SigNoz Cloud
```bash
# SigNoz Cloud endpoint
OTEL_EXPORTER_OTLP_ENDPOINT=https://ingest.{region}.signoz.cloud:443

# Set service name and other attributes
OTEL_RESOURCE_ATTRIBUTES="service.name=temporal-hello-world"

# SigNoz Cloud authentication
OTEL_EXPORTER_OTLP_HEADERS="signoz-ingestion-key=<your-signoz-key>"
```

### Step 8: Run Application

1. Start the worker:
```bash
mvn exec:java -Dexec.mainClass="helloworld.workers.HelloWorldWorker"
```

2. Execute workflows to generate metrics:
```bash
mvn exec:java -Dexec.mainClass="helloworld.main.HelloWorldStarter"
```

</TabItem>

<TabItem value="typescript" label="TypeScript">

### Step 1: Add OpenTelemetry Dependencies

Add the following dependencies to your `package.json`:

```json
{
  "dependencies": {
    "@grpc/grpc-js": "^1.9.0",
    "@opentelemetry/api": "^1.7.0", 
    "@opentelemetry/auto-instrumentations-node": "^0.56.1",
    "@opentelemetry/core": "^1.19.0",
    "@opentelemetry/exporter-metrics-otlp-grpc": "^0.46.0",
    "@opentelemetry/exporter-metrics-otlp-http": "^0.57.2",
    "@opentelemetry/exporter-trace-otlp-grpc": "^0.46.0",
    "@opentelemetry/exporter-trace-otlp-http": "^0.57.2",
    "@opentelemetry/exporter-trace-otlp-proto": "^0.57.2",
    "@opentelemetry/instrumentation": "^0.46.0",
    "@opentelemetry/resources": "^1.19.0",
    "@opentelemetry/sdk-metrics": "^1.19.0",
    "@opentelemetry/sdk-node": "^0.46.0",
    "@opentelemetry/sdk-trace-base": "^1.19.0",
    "@opentelemetry/sdk-trace-node": "^1.19.0",
    "@opentelemetry/semantic-conventions": "^1.19.0",
    "@temporalio/client": "^1.9.0",
    "@temporalio/common": "^1.9.0",
    "@temporalio/interceptors-opentelemetry": "^1.11.7",
    "@temporalio/worker": "^1.9.0",
    "@temporalio/workflow": "^1.9.0",
    "nanoid": "^5.1.4"
  }
}
```

### Step 2: Configure OpenTelemetry Utilities

Create `signozTelemetryUtils.ts` to manage OpenTelemetry SDK lifecycle and provide access to tracer and meter instances for SigNoz integration:

```typescript:src/config/signozTelemetryUtils.ts
import { diag, trace, metrics, Tracer, Meter } from '@opentelemetry/api';
import { NodeSDK } from '@opentelemetry/sdk-node';

// Persistent SDK and telemetry instances
let sdkInstance: NodeSDK | null = null;
let tracerInstance: Tracer | null = null;
let meterInstance: Meter | null = null;
let initialized = false;

export function getTracer(): Tracer {
    if (!tracerInstance) {
        tracerInstance = trace.getTracer('temporal-hello-world');
    }
    return tracerInstance;
}

export function getMeter(): Meter {
    if (!meterInstance) {
        meterInstance = metrics.getMeter('temporal-hello-world');
    }
    return meterInstance;
}

export function initializeTelemetry(): void {
    if (initialized) {
        return;
    }
    
    diag.info("Initializing OpenTelemetry...");
    
    try {
        // SDK initialization handled in opentelemetryConfig.ts
        
        // Create instances for later use
        tracerInstance = getTracer();
        meterInstance = getMeter();
        
        initialized = true;
        diag.info("OpenTelemetry initialized successfully");
    } catch (error) {
        diag.error(`Error initializing OpenTelemetry: ${error}`);
    }
}

export async function shutdownTelemetry(): Promise<void> {
    if (!sdkInstance) {
        return;
    }
    
    try {
        diag.info("Shutting down OpenTelemetry SDK...");
        await sdkInstance.shutdown();
        sdkInstance = null;
        tracerInstance = null;
        meterInstance = null;
        initialized = false;
        diag.info("OpenTelemetry SDK shut down successfully");
    } catch (error) {
        diag.error(`Error shutting down OpenTelemetry SDK: ${error}`);
    }
}

export function getSDK(): NodeSDK | null {
    return sdkInstance;
}

export function setSDK(sdk: NodeSDK): void {
    sdkInstance = sdk;
}

export async function forceSpanExport(): Promise<boolean> {
    if (!sdkInstance) {
        return false;
    }
        
    // Create a promise that times out after 5 seconds
    const timeoutPromise = new Promise<boolean>((resolve) => {
        setTimeout(() => {
            diag.warn('Span export timed out after 5 seconds');
            resolve(false);
        }, 5000);
    });
    
    // Create a promise for the shutdown
    const shutdownPromise = sdkInstance.shutdown().then(() => {
        diag.info('SDK shutdown complete, spans exported');
        // Reset instances after shutdown
        sdkInstance = null;
        tracerInstance = null;
        meterInstance = null;
        initialized = false;
        return true;
    }).catch(err => {
        diag.error('Error during SDK shutdown:', err);
        return false;
    });
    
    // Return the first promise that resolves
    return Promise.race([shutdownPromise, timeoutPromise]);
}

export function getServiceName(defaultServiceName: string = 'temporal-typescript-app'): string {
  if (process.env.OTEL_SERVICE_NAME) {
    return process.env.OTEL_SERVICE_NAME;
  }

  // Try to extract from OTEL_RESOURCE_ATTRIBUTES
  const resourceAttrs = process.env.OTEL_RESOURCE_ATTRIBUTES || '';
  const serviceNameMatch = resourceAttrs.match(/service\.name=([^,]+)/);
  
  if (serviceNameMatch && serviceNameMatch[1]) {
    return serviceNameMatch[1].trim();
  }
  
  return defaultServiceName;
}

// Export default object with all methods
export default {
    getTracer,
    getMeter,
    initializeTelemetry,
    shutdownTelemetry,
    forceSpanExport,
    getSDK,
    setSDK
};
```

### Step 3: Configure OpenTelemetry Metrics Exporter

Create `metricExporter.ts` to configure the metrics exporter:

```typescript:src/config/metricsExporter.ts
import { diag } from '@opentelemetry/api';
import { OTLPMetricExporter } from '@opentelemetry/exporter-metrics-otlp-grpc';
import { PeriodicExportingMetricReader, MetricReader } from '@opentelemetry/sdk-metrics';

export function configureMetricsEnvironment(): void {
    // Configure environment variables for metrics if not already set
    if (!process.env.OTEL_METRICS_EXPORTER) {
        process.env.OTEL_METRICS_EXPORTER = 'otlp';
    }
    
    if (!process.env.OTEL_EXPORTER_OTLP_PROTOCOL) {
        process.env.OTEL_EXPORTER_OTLP_PROTOCOL = 'grpc';
    }
    
    if (!process.env.OTEL_EXPORTER_OTLP_METRICS_ENDPOINT && process.env.OTEL_EXPORTER_OTLP_ENDPOINT) {
        process.env.OTEL_EXPORTER_OTLP_METRICS_ENDPOINT = process.env.OTEL_EXPORTER_OTLP_ENDPOINT;
    }
    
    process.env.OTEL_EXPORTER_OTLP_METRICS_TEMPORALITY_PREFERENCE = 'cumulative';
}

export function getMetricsReader(options?: { intervalMillis?: number }): MetricReader {
    const endpoint = process.env.OTEL_EXPORTER_OTLP_ENDPOINT || 'http://localhost:4317';
    const intervalMillis = options?.intervalMillis || 5000;
    
    console.log(`[METRICS] Configuring metrics reader with endpoint ${endpoint} and interval ${intervalMillis}ms`);
    
    // Get OpenTelemetry headers from environment variables
    const headers = getOtelHeaders();
    const headerKeys = Object.keys(headers);
    if (headerKeys.length > 0) {
        console.log(`[METRICS] Using headers: ${headerKeys.join(', ')}`);
    }
    
    // Create OTLP gRPC exporter
    const exporter = new OTLPMetricExporter({
        url: endpoint,
        timeoutMillis: 15000,
        headers: headers // Include any headers from env variables
    });
    
    // Create periodic reader with configured interval
    const reader = new PeriodicExportingMetricReader({
        exporter,
        exportIntervalMillis: intervalMillis,
        exportTimeoutMillis: Math.floor(intervalMillis * 0.8) // Set timeout to 80% of interval to ensure it's always less
    });
    
    return reader;
}

export function getOtelHeaders(): Record<string, string> {
    const headers: Record<string, string> = {};
    
    // Extract headers from environment variables
    Object.keys(process.env).forEach(key => {
        if (key.startsWith('OTEL_EXPORTER_OTLP_HEADERS_')) {
            const headerName = key.replace('OTEL_EXPORTER_OTLP_HEADERS_', '').toLowerCase();
            headers[headerName] = process.env[key] || '';
        }
    });
    
    return headers;
}

export default {
    getMetricsReader,
    getOtelHeaders,
    configureMetricsEnvironment
};
```

### Step 4: Configure OpenTelemetry SDK

Create `opentelemetryConfig.ts` to initialize the OpenTelemetry SDK:

```typescript:src/config/opentelemetryConfig.ts
import { Runtime } from '@temporalio/worker';
import { NodeSDK } from '@opentelemetry/sdk-node';
import { Resource } from '@opentelemetry/resources';
import { ATTR_SERVICE_NAME } from '@opentelemetry/semantic-conventions';
import { diag, DiagConsoleLogger, DiagLogLevel } from '@opentelemetry/api';
import { CompositePropagator, W3CTraceContextPropagator, W3CBaggagePropagator } from '@opentelemetry/core';
import { getNodeAutoInstrumentations } from '@opentelemetry/auto-instrumentations-node';
import { getMetricsReader } from './metricsExporter';
import { getTracingExporter, configureTracingEnvironment } from './tracingExporter';
import { configureMetricsEnvironment } from './metricsExporter';
import { setSDK } from './signozTelemetryUtils';
import { SemanticResourceAttributes } from '@opentelemetry/semantic-conventions';
import { registerInstrumentations } from '@opentelemetry/instrumentation';
import { OTLPTraceExporter } from '@opentelemetry/exporter-trace-otlp-proto';
import { OTLPMetricExporter } from '@opentelemetry/exporter-metrics-otlp-proto';
import { OTLPTraceExporter as OTLPTraceExporterHttp } from '@opentelemetry/exporter-trace-otlp-http';
import { OTLPMetricExporter as OTLPMetricExporterHttp } from '@opentelemetry/exporter-metrics-otlp-http';
import { PeriodicExportingMetricReader } from '@opentelemetry/sdk-metrics';
import { metrics } from '@opentelemetry/api';

// Define incubating semantic convention attributes
const ATTR_SERVICE_NAMESPACE = 'service.namespace';
const ATTR_DEPLOYMENT_ENVIRONMENT = 'deployment.environment';

// Logger configuration state
let loggerConfigured = false;

// Track if runtime is already installed
let isRuntimeInstalled = false;

export function getRuntimeEnvironment() {
  // Get environment information from process.env
  const environment = process.env.NODE_ENV || process.env.OTEL_ENVIRONMENT || 'development';
  
  // Basic attributes
  const attributes = {
    'service.namespace': process.env.TEMPORAL_NAMESPACE || 'default',
    'deployment.region': process.env.DEPLOYMENT_REGION || 'local',
    'host.name': process.env.HOSTNAME || 'localhost',
  };
  
  return {
    environment,
    attributes
  };
}

function configureLogger(logLevel: DiagLogLevel = DiagLogLevel.INFO): void {
    if (!loggerConfigured) {
        diag.setLogger(new DiagConsoleLogger(), logLevel);
        loggerConfigured = true;
        diag.info('[TELEMETRY] OpenTelemetry logger configured');
    }
}

function configureEnvironmentVariables(serviceName: string): void {
    // Configure core environment variables
    process.env.OTEL_SERVICE_NAME = serviceName;
    
    // Explicitly set OTLP exporter to avoid the "exporter not available" warning
    process.env.OTEL_TRACES_EXPORTER = 'otlp';
    process.env.OTEL_METRICS_EXPORTER = 'otlp';
    
    // Set default protocol if not specified
    if (!process.env.OTEL_EXPORTER_OTLP_PROTOCOL) {
        process.env.OTEL_EXPORTER_OTLP_PROTOCOL = 'grpc';
    }
    
    process.env.OTEL_PROPAGATORS = 'tracecontext,baggage';
    process.env.OTEL_LOGS_EXPORTER = 'none';
    
    // Configure tracing and metrics
    configureTracingEnvironment();
    configureMetricsEnvironment();
}

function createServiceResource(serviceName: string): Resource {
    const runtimeEnv = getRuntimeEnvironment();
    
    // Create a copy of attributes without service.namespace to avoid duplication
    const { 'service.namespace': _, ...otherAttributes } = runtimeEnv.attributes;
    
    return Resource.default().merge(
        new Resource({
            [ATTR_SERVICE_NAME]: serviceName,
            [ATTR_SERVICE_NAMESPACE]: runtimeEnv.attributes['service.namespace'],
            [ATTR_DEPLOYMENT_ENVIRONMENT]: runtimeEnv.environment,
            ...otherAttributes
        })
    );
}

export async function initOpenTelemetry(serviceName: string): Promise<void> {
    // Configure the OpenTelemetry logger
    configureLogger();
    
    // Configure environment variables
    configureEnvironmentVariables(serviceName);
    
    diag.info(`[TELEMETRY] Initializing OpenTelemetry for service: ${serviceName}`);
    
    const protocol = process.env.OTEL_EXPORTER_OTLP_PROTOCOL || 'grpc';
    const endpoint = process.env.OTEL_EXPORTER_OTLP_ENDPOINT || 'http://localhost:4317';
    
    diag.info(`[TELEMETRY] Configuring telemetry with ${protocol} protocol: ${endpoint}`);
    
    // Create instrumentation
    const instrumentations = getNodeAutoInstrumentations({
        '@opentelemetry/instrumentation-grpc': {
            ignoreGrpcMethods: []
        }
    });
    
    const traceExporter = getTracingExporter();
    
    // Create metrics reader with 5-second export interval (to match Java app)
    const metricsReader = getMetricsReader({ intervalMillis: 1000 });
    
    // Configure the SDK with explicit type casting to avoid linter errors due to library version mismatches
    const sdk = new NodeSDK({
        resource: createServiceResource(serviceName),
        traceExporter,
        instrumentations,
        spanProcessors: [],
        // @ts-ignore - Casting to avoid type errors between different OpenTelemetry package versions
        metricReader: metricsReader,
        textMapPropagator: new CompositePropagator({
            propagators: [
                new W3CTraceContextPropagator(),
                new W3CBaggagePropagator()
            ]
        })
    });
    
    // Store the SDK for later access
    setSDK(sdk);
    
    // Register SDK cleanup on process exit
    registerShutdownHandler(sdk);
    
    try {
        // Start the SDK
        await sdk.start();
        diag.info(`[TELEMETRY] OpenTelemetry SDK initialized successfully for ${serviceName}`);
    } catch (error) {
        diag.error(`[TELEMETRY] Failed to initialize OpenTelemetry SDK: ${error}`);
        throw error;
    }
    
    // Verify that metrics are enabled
    try {
        const meter = metrics.getMeter('verification');
        const counter = meter.createCounter('init_verification');
        counter.add(1, {
            'service.name': serviceName,
            'initialized': 'true'
        });
        diag.info('[TELEMETRY] Metrics recording verified successfully');
    } catch (error) {
        diag.warn(`[TELEMETRY] Failed to create verification metric: ${error}`);
    }
    
    // Install the OpenTelemetry SDK in Temporal Runtime
    try {
        await Runtime.install({
            telemetryOptions: {
                metrics: {
                    // @ts-ignore - The Temporal types may be out of date
                    enabled: true
                }
            }
        });
        diag.info('[TELEMETRY] Temporal Runtime installed with telemetry options');
    } catch (err) {
        diag.error(`[TELEMETRY] Failed to install Temporal Runtime with telemetry: ${err}`);
    }
}

function registerShutdownHandler(sdk: NodeSDK): void {
    // Only register for uncaught exceptions, let the worker handle SIGTERM/SIGINT
    // to prevent conflicts with multiple handlers
    
    // Handle uncaught errors
    process.on('uncaughtException', async (error) => {
        diag.error('[TELEMETRY] Uncaught exception, shutting down telemetry before exit:', error);
        
        try {
            const shutdownPromise = sdk.shutdown();
            const timeoutPromise = new Promise((_, reject) => 
                setTimeout(() => reject(new Error('Shutdown timed out')), 5000)
            );
            
            await Promise.race([shutdownPromise, timeoutPromise]);
            diag.info('[TELEMETRY] OpenTelemetry SDK shut down successfully');
        } catch (error) {
            diag.error('[TELEMETRY] Error shutting down OpenTelemetry SDK:', 
                error instanceof Error ? error.message : String(error));
        }
    });
}
```

### Step 5: Configure Temporal Telemetry Options & Dashboard Metrics
Create `temporalConfig.ts` to configure Temporal SDK clients, workers, and dashboard metrics using OpenTelemetry:

```
import { WorkerOptions } from '@temporalio/worker';
import { WorkflowClientOptions } from '@temporalio/client';
import * as WorkflowMetricsUtil from './workflowMetricsUtil';
import { diag } from '@opentelemetry/api';
import { OTLPMetricExporter } from '@opentelemetry/exporter-metrics-otlp-grpc';
import { PayloadConverter, ValueError, Payload } from '@temporalio/common';
import { getServiceName } from './signozTelemetryUtils';

// Add type declaration for globalThis
declare global {
  var __dashboardMetricsInterval: NodeJS.Timeout | undefined;
  var __dashboardMetricsInitialTimer: NodeJS.Timeout | undefined;
}

// ...

export const DEFAULT_TASK_QUEUE = 'hello-world';

export function configureTemporalEnvironment(options?: { 
    namespace?: string,
    serverUrl?: string 
}): void {
    // Set default or provided Temporal environment variables
    process.env.TEMPORAL_SERVER_URL = options?.serverUrl || 'localhost:7233';
    process.env.TEMPORAL_NAMESPACE = options?.namespace || 'default';
}

export function registerDashboardMetrics(options?: {
    initialDelayMs?: number,
    intervalMs?: number
}): () => void {
    const initialDelayMs = options?.initialDelayMs || 1000;
    const intervalMs = options?.intervalMs || 5000; // Match Java default (5000ms)
    
    diag.info(`[METRICS] Registering dashboard metrics with interval ${intervalMs}ms and initial delay ${initialDelayMs}ms`);
    console.log(`[METRICS] Registering dashboard metrics with interval ${intervalMs}ms and initial delay ${initialDelayMs}ms`);
    
    // Get service name from environment variables
    const serviceName = getServiceName('worker');
    
    // Record a service restart event
    WorkflowMetricsUtil.recordServiceRestart("worker");
    WorkflowMetricsUtil.recordSystemMetrics(serviceName);
    
    // Set initial timer
    const initialTimer = setTimeout(() => {
        // Send initial metrics
        diag.debug('[METRICS] Sending initial dashboard metrics');
        console.log('[METRICS] Sending initial dashboard metrics');
        
        // Generate sample workflow IDs and run IDs for metrics
        const workflowId = 'sample-workflow-id';
        const runId = 'sample-run-id';
        const namespace = 'default';
        
        // Emit initial metrics
        emitPeriodicMetrics(workflowId, runId, namespace);
        
        // Then set up interval
        const interval = setInterval(() => {
            diag.debug('[METRICS] Sending periodic dashboard metrics');
            console.log('[METRICS] Sending periodic dashboard metrics');
            emitPeriodicMetrics(workflowId, runId, namespace);
        }, intervalMs);
        
        // Store interval for cleanup
        globalThis.__dashboardMetricsInterval = interval;
    }, initialDelayMs);
    
    // Store the initial timer for cleanup
    globalThis.__dashboardMetricsInitialTimer = initialTimer;
    
    // Return a function to stop sending metrics
    return () => {
        diag.info('[METRICS] Dashboard metrics registration stopped');
        console.log('[METRICS] Dashboard metrics registration stopped');
        
        if (globalThis.__dashboardMetricsInitialTimer) {
            clearTimeout(globalThis.__dashboardMetricsInitialTimer);
            delete globalThis.__dashboardMetricsInitialTimer;
        }
        
        if (globalThis.__dashboardMetricsInterval) {
            clearInterval(globalThis.__dashboardMetricsInterval);
            delete globalThis.__dashboardMetricsInterval;
        }
    };
}

// ...

export function emitPeriodicMetrics(workflowId: string, runId: string, namespace: string): void {
    // Workflow types to emit metrics for
    const workflowTypes = [
        'HelloWorldWorkflow',
        // ... more workflow types.
    ];
    
    console.log(`[METRICS] Emitting metrics for workflow ID ${workflowId}, run ID ${runId}, namespace ${namespace}`);
    
    // Emit metrics for each workflow type
    workflowTypes.forEach(workflowType => {
        // Workflow state metrics
        WorkflowMetricsUtil.recordSuccess(workflowType, `${workflowId}-success`, runId, namespace);
        WorkflowMetricsUtil.recordFailure(workflowType, `${workflowId}-failure`, runId, namespace);
        // Record other workflow states like timeout, termination, cancellation etc.
        
        // Service request metrics
        WorkflowMetricsUtil.recordAddActivityTask();
        WorkflowMetricsUtil.recordRecordActivityTaskStarted();
        WorkflowMetricsUtil.recordResponseActivityCompleted();
        // ... and similar methods for other activity and workflow task metrics
        
        // Service error metrics
        WorkflowMetricsUtil.recordAddActivityTaskError();
        WorkflowMetricsUtil.recordRecordActivityTaskStartedError();
        WorkflowMetricsUtil.recordValidationError();
        // ... and similar methods for other error metrics
        
        // Timeout metrics
        WorkflowMetricsUtil.recordScheduleToStartWorkflowTimeout();
        WorkflowMetricsUtil.recordStartToCloseWorkflowTimeout();
    });
    
    // Service metrics
    WorkflowMetricsUtil.recordServiceRestart('worker');
    WorkflowMetricsUtil.recordServiceRestart('frontend');
    
}
```

### Step 6: Configure Workflow Client with Metrics

Create a client with OpenTelemetry metrics instrumentation:

```typescript:src/client.ts
import { Client } from '@temporalio/client';
import { initOpenTelemetry } from './config/opentelemetryConfig';
import { getMeter } from './config/signozTelemetryUtils';
import { registerDashboardMetrics } from './config/temporalConfig';
import { OpenTelemetryWorkflowClientInterceptor } from '@temporalio/interceptors-opentelemetry';
import * as WorkflowMetricsUtil from './config/workflowMetricsUtil';

async function run() {
  // 1. Configure metrics export settings
  process.env.OTEL_EXPORTER_OTLP_ENDPOINT = process.env.OTEL_EXPORTER_OTLP_ENDPOINT || 'http://localhost:4317';
  process.env.OTEL_METRICS_EXPORT_INTERVAL = '5000'; // 5-second export interval
  process.env.OTEL_METRICS_EXPORT_TIMEOUT = '4000'; // Shorter than interval

  // 2. Initialize OpenTelemetry metrics
  await initOpenTelemetry('temporal-hello-world-client');
  WorkflowMetricsUtil.initializeMetrics();
  const stopMetrics = registerDashboardMetrics(); // Start periodic metrics

  // 3. Create metric instruments
  const meter = getMeter();
  const workflowStartCounter = meter.createCounter('workflow_started_count_total', {
    description: 'Total workflow executions started'
  });
  
  const workflowCompletionCounter = meter.createCounter('workflow_completed_count_total', {
    description: 'Total workflow executions completed'
  });

  // 4. Configure client with metrics interceptor
  const client = new Client({
    ... //connection config
    interceptors: {
      workflow: [new OpenTelemetryWorkflowClientInterceptor()] // Metrics collection
    }
  });

  try {
    // 5. Record workflow start metric
    workflowStartCounter.add(1, { 'workflow_type': 'HelloWorld' });
    WorkflowMetricsUtil.recordServiceRequest('StartWorkflow');

    ... // Workflow execution logic

    // 6. Record success metrics
    workflowCompletionCounter.add(1, { 'workflow_type': 'HelloWorld' });
    WorkflowMetricsUtil.recordSuccess(...);
    
  } catch (error) {
    // 7. Record failure metrics
    workflowCompletionCounter.add(1);
    WorkflowMetricsUtil.recordFailure(...);
    ...
  } finally {
    // 8. Cleanup metrics resources
    stopMetrics();
    await new Promise(resolve => setTimeout(resolve, 5000)); // Final export
    WorkflowMetricsUtil.cleanup();
  }
}

run().catch(err => {
  console.error('Fatal error:', err);
  process.exit(1);
});
```

### Step 7: Configure Environment Variables

```bash
# SigNoz endpoint
# SigNoz Cloud endpoint
OTEL_EXPORTER_OTLP_ENDPOINT=https://ingest.{region}.signoz.cloud:443

# Set service name and other attributes
OTEL_RESOURCE_ATTRIBUTES="service.name=temporal-hello-world"

# SigNoz Cloud authentication
OTEL_EXPORTER_OTLP_HEADERS="signoz-ingestion-key=<your-signoz-key>"
```

### Step 8: Run Application

1. Start the worker:
```bash
npm run worker
```

2. Execute a workflow to generate metrics:
```bash
npm run workflow
```

</TabItem>

<TabItem value="go" label="Go">

### Step 1: Add OpenTelemetry Dependencies

Add the following dependencies to your `go.mod`:

```go
require (
	go.opentelemetry.io/otel v1.24.0
	go.opentelemetry.io/otel/exporters/otlp/otlpmetric/otlpmetricgrpc v1.24.0
	go.opentelemetry.io/otel/exporters/otlp/otlptrace v1.24.0
	go.opentelemetry.io/otel/exporters/otlp/otlptrace/otlptracegrpc v1.24.0
	go.opentelemetry.io/otel/metric v1.24.0
	go.opentelemetry.io/otel/sdk v1.24.0
	go.opentelemetry.io/otel/sdk/metric v1.24.0
	go.opentelemetry.io/otel/trace v1.24.0
	go.opentelemetry.io/proto/otlp v1.1.0
	go.temporal.io/api v1.24.0
	go.temporal.io/sdk v1.25.1
	go.temporal.io/sdk/contrib/opentelemetry v0.3.0
	google.golang.org/grpc v1.61.1
)
```

### Step 2: Configure OpenTelemetry

Create `signoz_telemetry_utils.go` to coordinate the OpenTelemetry components:

```go:internal/helloworld/config/signoz_telemetry_utils.go
package config

import (
	"context"
	"fmt"
	"log"
	"time"

	"go.opentelemetry.io/otel"
)

// SignozTelemetryUtils coordinates all telemetry components
type SignozTelemetryUtils struct {
	otelConfig *OpenTelemetryConfig
}

// NewSignozTelemetryUtils creates a new telemetry configuration
func NewSignozTelemetryUtils() *SignozTelemetryUtils {
	return &SignozTelemetryUtils{
		otelConfig: NewOpenTelemetryConfig(),
	}
}

// InitProvider initializes all telemetry providers
func (c *SignozTelemetryUtils) InitProvider(ctx context.Context) (func(), error) {
	// Create resource
	res, err := c.otelConfig.CreateResource(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed to create resource: %w", err)
	}

	// Get TLS credentials
	creds := c.otelConfig.GetTLSCredentials()

	// Initialize metrics
	metricsConfig := &MetricsExporterConfig{
		ServiceName: c.otelConfig.ServiceName,
		Environment: c.otelConfig.Environment,
		Endpoint:    c.otelConfig.Endpoint,
		Headers:     c.otelConfig.Headers,
		TLSCreds:    creds,
	}
	meterProvider, err := NewMetricsExporter(ctx, metricsConfig, res)
	if err != nil {
		return nil, fmt.Errorf("failed to create metrics exporter: %w", err)
	}

	// Set global meter provider
	otel.SetMeterProvider(meterProvider)

	// Initialize tracing
	tracingConfig := &TracingExporterConfig{
		ServiceName: c.otelConfig.ServiceName,
		Environment: c.otelConfig.Environment,
		Endpoint:    c.otelConfig.Endpoint,
		Headers:     c.otelConfig.Headers,
		TLSCreds:    creds,
	}
	tracerProvider, err := NewTracingExporter(ctx, tracingConfig, res)
	if err != nil {
		return nil, fmt.Errorf("failed to create tracer provider: %w", err)
	}

	// Set global tracer provider
	otel.SetTracerProvider(tracerProvider)

	// Setup propagator
	SetupPropagator()

	// Return cleanup function
	cleanup := func() {
		shutdownCtx, cancel := context.WithTimeout(context.Background(), 30*time.Second)
		defer cancel()

		if err := tracerProvider.Shutdown(shutdownCtx); err != nil {
			log.Printf("[ERROR] Error shutting down tracer provider: %v\n", err)
		}

		if err := meterProvider.Shutdown(shutdownCtx); err != nil {
			log.Printf("[ERROR] Error shutting down meter provider: %v\n", err)
		}
	}

	return cleanup, nil
}
```

### Step 3: Configure OpenTelemetry Settings

Create `opentelemetry_config.go` to manage OpenTelemetry configuration:

```go:internal/helloworld/config/opentelemetry_config.go
package config

import (
	"context"
	"fmt"
	"os"
	"strings"

	"go.opentelemetry.io/otel"
	"go.opentelemetry.io/otel/propagation"
	"go.opentelemetry.io/otel/sdk/resource"
	semconv "go.opentelemetry.io/otel/semconv/v1.24.0"
	"google.golang.org/grpc/credentials"
	"google.golang.org/grpc/credentials/insecure"
)

// OpenTelemetryConfig holds OpenTelemetry configuration
type OpenTelemetryConfig struct {
	ServiceName string
	Environment string
	Endpoint    string
	Headers     map[string]string
	UseTLS      bool
}

// NewOpenTelemetryConfig creates a new OpenTelemetry configuration
func NewOpenTelemetryConfig() *OpenTelemetryConfig {
	endpoint := os.Getenv("OTEL_EXPORTER_OTLP_ENDPOINT")
	useTLS := false

	if endpoint == "" {
		endpoint = "localhost:4317"
	} else {
		// Check if this is a cloud endpoint that needs TLS
		if strings.Contains(endpoint, "https://") || strings.Contains(endpoint, "signoz.cloud") {
			useTLS = true
			// For gRPC, we don't need the https:// prefix
			endpoint = strings.TrimPrefix(strings.TrimPrefix(endpoint, "https://"), "http://")
		} else {
			// For non-TLS endpoint
			endpoint = strings.TrimPrefix(strings.TrimPrefix(endpoint, "http://"), "https://")
		}
	}

	// Debug output
	headers := parseHeaders()
	fmt.Printf("[DEBUG] OTEL endpoint: %s\n", endpoint)
	fmt.Printf("[DEBUG] OTEL headers: %v\n", headers)
	fmt.Printf("[DEBUG] OTEL using TLS: %v\n", useTLS)

	return &OpenTelemetryConfig{
		ServiceName: "temporal-hello-world",
		Environment: "development",
		Endpoint:    endpoint,
		Headers:     headers,
		UseTLS:      useTLS,
	}
}

// CreateResource creates a new resource with common attributes
func (c *OpenTelemetryConfig) CreateResource(ctx context.Context) (*resource.Resource, error) {
	hostname, _ := os.Hostname()
	return resource.New(ctx,
		resource.WithAttributes(
			semconv.ServiceName(c.ServiceName),
			semconv.ServiceVersion("1.0.0"),
			semconv.DeploymentEnvironment(c.Environment),
			semconv.HostName(hostname),
			semconv.ServiceInstanceID(fmt.Sprintf("%s-%d", hostname, os.Getpid())),
		),
		resource.WithSchemaURL(semconv.SchemaURL),
	)
}

// GetTLSCredentials returns the appropriate TLS credentials
func (c *OpenTelemetryConfig) GetTLSCredentials() credentials.TransportCredentials {
	fmt.Printf("[DEBUG] Getting TLS credentials, UseTLS: %v\n", c.UseTLS)
	if c.UseTLS {
		return credentials.NewClientTLSFromCert(nil, "")
	}
	return insecure.NewCredentials()
}

// SetupPropagator configures the global propagator
func SetupPropagator() {
	otel.SetTextMapPropagator(propagation.NewCompositeTextMapPropagator(
		propagation.TraceContext{},
		propagation.Baggage{},
	))
}

// GetSpanAttributes returns a map of common attributes for spans
func GetSpanAttributes(workflowType, workflowID, taskQueue string) map[string]string {
	attrs := make(map[string]string)
	attrs["workflow_type"] = workflowType
	attrs["workflow_id"] = workflowID
	attrs["task_queue"] = taskQueue
	attrs["namespace"] = "default" // Default namespace, can be overridden if needed
	return attrs
}

// parseHeaders parses OTEL_EXPORTER_OTLP_HEADERS environment variable
func parseHeaders() map[string]string {
	headers := make(map[string]string)
	headerStr := os.Getenv("OTEL_EXPORTER_OTLP_HEADERS")
	if headerStr != "" {
		// Parse headers in format "key1=value1,key2=value2"
		pairs := strings.Split(headerStr, ",")
		for _, pair := range pairs {
			kv := strings.SplitN(pair, "=", 2)
			if len(kv) == 2 {
				headers[strings.TrimSpace(kv[0])] = strings.TrimSpace(kv[1])
			}
		}
	}
	return headers
}
```

### Step 4: Set Up Metrics Export

Create `metrics_exporter.go` to configure the OTLP trace exporter:

```go:internal/helloworld/config/metrics_exporter.go
package config

import (
	"context"
	"fmt"
	"time"

	"go.opentelemetry.io/otel/attribute"
	"go.opentelemetry.io/otel/exporters/otlp/otlpmetric/otlpmetricgrpc"
	"go.opentelemetry.io/otel/metric"
	sdkmetric "go.opentelemetry.io/otel/sdk/metric"
	"go.opentelemetry.io/otel/sdk/resource"
	"google.golang.org/grpc/credentials"
)

// MetricsExporterConfig holds configuration for metrics export
type MetricsExporterConfig struct {
	ServiceName string
	Environment string
	Endpoint    string
	Headers     map[string]string
	TLSCreds    credentials.TransportCredentials
}

// NewMetricsExporter creates and configures the metrics exporter
func NewMetricsExporter(ctx context.Context, cfg *MetricsExporterConfig, res *resource.Resource) (*sdkmetric.MeterProvider, error) {
	// Configure metrics exporter
	exporter, err := otlpmetricgrpc.New(ctx,
		otlpmetricgrpc.WithEndpoint(cfg.Endpoint),
		otlpmetricgrpc.WithHeaders(cfg.Headers),
		otlpmetricgrpc.WithTLSCredentials(cfg.TLSCreds),
		otlpmetricgrpc.WithRetry(otlpmetricgrpc.RetryConfig{
			Enabled:         true,
			InitialInterval: 1 * time.Second,
			MaxInterval:     5 * time.Second,
			MaxElapsedTime:  30 * time.Second,
		}),
	)
	if err != nil {
		return nil, fmt.Errorf("failed to create metrics exporter: %w", err)
	}

	// Configure periodic reader with more frequent reporting
	reader := sdkmetric.NewPeriodicReader(
		exporter,
		sdkmetric.WithInterval(1*time.Second),
	)

	// Create meter provider
	mp := sdkmetric.NewMeterProvider(
		sdkmetric.WithResource(res),
		sdkmetric.WithReader(reader),
	)

	// Register common metrics
	meter := mp.Meter("temporal-hello-world")
	if err := RegisterCommonMetrics(meter); err != nil {
		return nil, fmt.Errorf("failed to register common metrics: %w", err)
	}

	return mp, nil
}

// RegisterCommonMetrics registers metrics that are common across the application
func RegisterCommonMetrics(meter metric.Meter, attrs ...attribute.KeyValue) error {
	// Initialize all workflow metrics using our WorkflowMetricsUtil equivalent
	return InitializeMetrics(meter)
}
```

### Step 5: Configure  Dashboard Metrics
Create `workflow_metrics_util.go` to configure Temporal SDK clients, workers, and dashboard metrics using OpenTelemetry:

```go:internal/helloworld/config/workflow_metrics_util.go
package config

import (
	"context"
	"log"
	"sync"

	"go.opentelemetry.io/otel"
	"go.opentelemetry.io/otel/attribute"
	"go.opentelemetry.io/otel/metric"
)

var (
	// Metric counters
	workflowSuccess metric.Int64Counter
	workflowFailed  metric.Int64Counter
	// ... other metric variables

	// Common attributes
	WorkflowTypeKey = attribute.Key("workflow_type")
	WorkflowIDKey   = attribute.Key("workflow_id")
	RunIDKey        = attribute.Key("run_id")
	NamespaceKey    = attribute.Key("namespace")
	OperationKey    = attribute.Key("operation")
	// ... other attribute keys

	once sync.Once
)

// Helper to create a counter with common options
func createCounter(meter metric.Meter, name, desc, unit string) (metric.Int64Counter, error) {
	return meter.Int64Counter(
		name,
		metric.WithDescription(desc),
		metric.WithUnit(unit),
	)
}

// InitializeMetrics registers workflow and service metrics
func InitializeMetrics(meter metric.Meter) error {
	var err error

	workflowSuccess, err = createCounter(meter, "workflow_success", "Count of successfully completed workflows", "{execution}")
	if err != nil {
		return err
	}

	workflowFailed, err = createCounter(meter, "workflow_failed", "Count of failed workflows", "{execution}")
	if err != nil {
		return err
	}

	// ... initialize other metrics similarly

	return nil
}

// Ensures metrics are initialized only once
func ensureMetricsInitialized() {
	once.Do(func() {
		log.Println("Initializing metrics counters...")
		meter := otel.GetMeterProvider().Meter("temporal-metrics")
		if err := InitializeMetrics(meter); err != nil {
			log.Printf("Failed to initialize metrics: %v", err)
		} else {
			log.Println("Metrics counters initialized successfully")
		}
	})
}

// Helper to record metrics with common attributes
func recordCounter(ctx context.Context, counter metric.Int64Counter, attrs ...attribute.KeyValue) {
	ensureMetricsInitialized()
	counter.Add(ctx, 1, metric.WithAttributes(attrs...))
}

// Example usage: record workflow success
func RecordSuccess(ctx context.Context, workflowType, workflowID, runID, namespace string) {
	recordCounter(ctx, workflowSuccess,
		WorkflowTypeKey.String(workflowType),
		WorkflowIDKey.String(workflowID),
		RunIDKey.String(runID),
		NamespaceKey.String(namespace),
		OperationKey.String("CompletionStats"),
	)
}

// ...
```

### Step 6: Configure Main Application with OpenTelemetry

```go:cmd/helloworld/main.go
package main

import (
	"context"
	"log"
	"os"
	"os/signal"
	"syscall"
	"time"

	"github.com/creator54/temporal-go-demo-app/internal/helloworld/config"
	"go.opentelemetry.io/otel"
)

func main() {
	// 1. Context and signal handling setup (essential for clean shutdown)
	ctx, cancel := context.WithCancel(context.Background())
	defer cancel()

	sigChan := make(chan os.Signal, 1)
	signal.Notify(sigChan, os.Interrupt, syscall.SIGTERM)
	go func() {
		sig := <-sigChan
		log.Printf("METRICS: Received %v - initiating shutdown", sig)
		cancel()
	}()

	// 2. OpenTelemetry metrics initialization
	log.SetFlags(log.LstdFlags | log.Lmicroseconds)
	log.Println("METRICS: Initializing OpenTelemetry...")

	telemetry := config.NewSignozTelemetryUtils()
	cleanup, err := telemetry.InitProvider(ctx)
	if err != nil {
		log.Fatalf("METRICS: Failed to initialize - %v", err)
	}
	defer func() {
		log.Println("METRICS: Flushing remaining metrics...")
		cleanup()
	}()

	// 3. Metrics instrumentation setup
	log.Println("METRICS: Creating metric instruments...")
	meter := otel.GetMeterProvider().Meter("temporal-metrics")
	if err := config.InitializeMetrics(meter); err != nil {
		log.Fatalf("METRICS: Instrumentation failed - %v", err)
	}

	// ... (Temporal worker/workflow setup would go here)
	
	// 4. Maintain context until shutdown
	<-ctx.Done()
	log.Println("METRICS: Final export buffer...")
	time.Sleep(2 * time.Second) // Allow final metric exports
}
```

### Step 7: Configure Environment Variables

```bash
# SigNoz endpoint
export OTEL_EXPORTER_OTLP_ENDPOINT="http://localhost:4317"

# Set service name and other attributes
OTEL_RESOURCE_ATTRIBUTES="service.name=temporal-hello-world"
```

### Step 8: Run Application

1. Start the worker:
```bash
go run ./cmd/helloworld -worker
```

2. Execute a workflow to generate metrics:
```bash
go run ./cmd/helloworld
```

</TabItem>
</Tabs>
</TabItem>
</Tabs>

## Monitoring in SigNoz

### View Services

Navigate to the `Services` tab to find your Temporal application:

<figure data-zoomable align='center'>
<img src="/img/docs/instrumentation/temporal-services.webp" alt="Services view"/>
<figcaption><i>Services overview showing Temporal application</i></figcaption>
</figure>

### Analyze Metrics

Navigate to the `Dashboard` tab, click on `+ New dashboard` and import our pre-built Temporal dashboard from [GitHub](https://github.com/SigNoz/dashboards/blob/main/temporal.io/temporal_metrics.json) to get a comprehensive view of your Temporal application metrics.

The dashboard includes key metrics like:
- Workflow execution metrics
- Activity completion rates  
- Task queue latencies
- Error rates and failures
- Resource utilization

<figure data-zoomable align='center'>
<img src="/img/docs/instrumentation/temporal-metrics.webp" alt="Metrics view"/>
<figcaption><i>Temporal Server Metrics dashboard showing workflow performance and service health</i></figcaption>
</figure>

## Sample Application

Check out our sample applications on GitHub:
- [Java Sample App](https://github.com/Creator54/temporal-java-demo-app)
- [TypeScript Sample App](https://github.com/Creator54/temporal-typescript-demo-app)
- [Go Sample App](https://github.com/Creator54/temporal-go-demo-app)
- Use the `main` branch to follow along with the implementation steps
- Switch to the `otel` branch to see the complete OpenTelemetry integration

## Troubleshooting

### Common Issues

1. **No Metrics Visible**
   - Verify SigNoz endpoint configuration
   - Check ingestion key (for SigNoz Cloud)
   - Ensure OpenTelemetry initialization succeeds
   - Verify Temporal server is running

2. **Connection Issues**
   - Check network connectivity
   - Verify endpoint protocol (http/https)
   - Check port accessibility
   - Verify TLS configuration (if using SigNoz Cloud)
   - Restart Temporal server (if using temporal self-hosted)